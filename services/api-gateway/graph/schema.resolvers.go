package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"strconv"

	"github.com/damarteplok/damar-admin-cms/services/api-gateway/graph/model"
	"github.com/damarteplok/damar-admin-cms/services/api-gateway/internal/middleware"
	authPb "github.com/damarteplok/damar-admin-cms/shared/proto/auth"
	productPb "github.com/damarteplok/damar-admin-cms/shared/proto/product"
	tenantPb "github.com/damarteplok/damar-admin-cms/shared/proto/tenant"
	userPb "github.com/damarteplok/damar-admin-cms/shared/proto/user"
	"github.com/damarteplok/damar-admin-cms/shared/util"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Login(ctx, &authPb.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: fmt.Sprintf("Login failed: %v", err),
		}, nil
	}

	// Convert proto response to GraphQL model
	if !resp.Success {
		return &model.LoginResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	userData := resp.Data
	emailVerifiedAt := int32(userData.User.EmailVerifiedAt)
	lastLoginAt := int32(userData.User.LastLoginAt)
	createdAt := int32(userData.User.CreatedAt)
	updatedAt := int32(userData.User.UpdatedAt)

	return &model.LoginResponse{
		Success: true,
		Message: "Login successful",
		Data: &model.LoginData{
			AccessToken:  userData.AccessToken,
			RefreshToken: userData.RefreshToken,
			User: &model.User{
				ID:              fmt.Sprintf("%d", userData.User.Id),
				Name:            userData.User.Name,
				Email:           userData.User.Email,
				PublicName:      &userData.User.PublicName,
				IsAdmin:         userData.User.IsAdmin,
				IsBlocked:       userData.User.IsBlocked,
				PhoneNumber:     &userData.User.PhoneNumber,
				Position:        &userData.User.Position,
				EmailVerified:   userData.User.EmailVerified,
				EmailVerifiedAt: &emailVerifiedAt,
				LastLoginAt:     &lastLoginAt,
				CreatedAt:       &createdAt,
				UpdatedAt:       &updatedAt,
			},
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, refreshToken string) (*model.LogoutResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Logout(ctx, &authPb.LogoutRequest{
		RefreshToken: refreshToken,
	})
	if err != nil {
		return &model.LogoutResponse{
			Success: false,
			Message: fmt.Sprintf("Logout failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.LogoutResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.LogoutResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.RefreshTokenResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.RefreshToken(ctx, &authPb.RefreshTokenRequest{
		RefreshToken: input.RefreshToken,
	})
	if err != nil {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: fmt.Sprintf("Refresh token failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.RefreshTokenResponse{
		Success: true,
		Message: "Token refreshed successfully",
		Data: &model.RefreshTokenData{
			AccessToken:  resp.Data.AccessToken,
			RefreshToken: resp.Data.RefreshToken,
		},
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (*model.ChangePasswordResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.ChangePassword(ctx, &authPb.ChangePasswordRequest{
		UserId:      currentUser.Id,
		OldPassword: input.OldPassword,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Change password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ChangePasswordResponse{
		Success: true,
		Message: "Password changed successfully",
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ForgotPassword(ctx, &authPb.ForgotPasswordRequest{
		Email: email,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Forgot password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Password reset email sent successfully",
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ResetPassword(ctx, &authPb.ResetPasswordRequest{
		Token:       input.Token,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Reset password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ResetPasswordResponse{
		Success: true,
		Message: "Password reset successfully",
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (*model.VerifyEmailResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyEmail(ctx, &authPb.VerifyEmailRequest{
		Token: token,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Email verification failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Email verified successfully",
	}, nil
}

// ResendVerificationEmail is the resolver for the resendVerificationEmail field.
func (r *mutationResolver) ResendVerificationEmail(ctx context.Context) (*model.VerifyEmailResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user email from user-service
	userResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !userResp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: "Failed to get user information",
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: currentUser.Id,
		Email:  userResp.Data.Email,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Resend verification email failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Verification email sent successfully",
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserResponse, error) {
	// Public registration - no auth check needed
	isAdmin := false
	if input.IsAdmin != nil {
		isAdmin = *input.IsAdmin
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.CreateUser(ctx, &userPb.CreateUserRequest{
		Name:        input.Name,
		Email:       input.Email,
		Password:    input.Password,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdmin,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Create user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Generate verification token after user creation
	verifyResp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: resp.Data.Id,
		Email:  resp.Data.Email,
	})
	if err != nil || !verifyResp.Success {
		// Log error but don't fail user creation
		// User can resend verification email later
		fmt.Printf("Warning: Failed to send verification email: %v\n", err)
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User created successfully. Please check your email to verify your account.",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.UserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: owner OR admin
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.UserResponse{
			Success: false,
			Message: "Forbidden: You can only update your own profile or be an admin",
		}, nil
	}

	// Prepare update request
	isAdminValue := false
	if input.IsAdmin != nil {
		isAdminValue = *input.IsAdmin
	}
	isBlockedValue := false
	if input.IsBlocked != nil {
		isBlockedValue = *input.IsBlocked
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.UpdateUser(ctx, &userPb.UpdateUserRequest{
		Id:          targetUserID,
		Name:        input.Name,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdminValue,
		IsBlocked:   isBlockedValue,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Update user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User updated successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.DeleteUserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: admin only OR own account
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Forbidden: Only admins can delete users or you can delete your own account",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.DeleteUser(ctx, &userPb.DeleteUserRequest{
		Id: targetUserID,
	})
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: fmt.Sprintf("Delete user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.DeleteUserResponse{
		Success: true,
		Message: "User deleted successfully",
	}, nil
}

// BulkDeleteUsers is the resolver for the bulkDeleteUsers field.
func (r *mutationResolver) BulkDeleteUsers(ctx context.Context, ids []string) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk delete users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkDeleteUsers(ctx, &userPb.BulkDeleteUsersRequest{
		UserIds: userIDs,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk delete users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.DeletedCount,
		}, nil
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       "Users deleted successfully",
		AffectedCount: resp.DeletedCount,
	}, nil
}

// BulkBlockUsers is the resolver for the bulkBlockUsers field.
func (r *mutationResolver) BulkBlockUsers(ctx context.Context, ids []string, isBlocked bool) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk block/unblock users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkBlockUsers(ctx, &userPb.BulkBlockUsersRequest{
		UserIds:   userIDs,
		IsBlocked: isBlocked,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk block users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.AffectedCount,
		}, nil
	}

	action := "blocked"
	if !isBlocked {
		action = "unblocked"
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       fmt.Sprintf("Users %s successfully", action),
		AffectedCount: resp.AffectedCount,
	}, nil
}

// CreateTenant is the resolver for the createTenant field.
func (r *mutationResolver) CreateTenant(ctx context.Context, input model.CreateTenantInput) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.CreateTenant(ctx, &tenantPb.CreateTenantRequest{
		Name:      input.Name,
		Slug:      util.StringValue(input.Slug),
		Domain:    util.StringValue(input.Domain),
		CreatedBy: userClaims.Id,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant created successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input model.UpdateTenantInput) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.UpdateTenant(ctx, &tenantPb.UpdateTenantRequest{
		Id:     tenantID,
		Name:   input.Name,
		Domain: util.StringValue(input.Domain),
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to update tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant updated successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// DeleteTenant is the resolver for the deleteTenant field.
func (r *mutationResolver) DeleteTenant(ctx context.Context, id string) (*model.DeleteTenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.DeleteTenant(ctx, &tenantPb.DeleteTenantRequest{
		Id: tenantID,
	})
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to delete tenant: %v", err),
		}, nil
	}

	return &model.DeleteTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// AddUserToTenant is the resolver for the addUserToTenant field.
func (r *mutationResolver) AddUserToTenant(ctx context.Context, input model.AddUserToTenantInput) (*model.TenantUserResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Get user email first
	userResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: userID,
	})
	if err != nil || !userResp.Success {
		return &model.TenantUserResponse{
			Success: false,
			Message: "User not found",
		}, nil
	}

	isDefault := false
	if input.IsDefault != nil {
		isDefault = *input.IsDefault
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.AddUserToTenant(ctx, &tenantPb.AddUserToTenantRequest{
		UserId:    userID,
		TenantId:  tenantID,
		Role:      input.Role,
		IsDefault: isDefault,
		Email:     userResp.Data.Email,
	})
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to add user to tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenantUser := resp.Data
	return &model.TenantUserResponse{
		Success: true,
		Message: "User added to tenant successfully",
		Data: &model.TenantUser{
			ID:        strconv.FormatInt(tenantUser.Id, 10),
			UserID:    strconv.FormatInt(tenantUser.UserId, 10),
			TenantID:  strconv.FormatInt(tenantUser.TenantId, 10),
			Role:      tenantUser.Role,
			IsDefault: tenantUser.IsDefault,
			Email:     tenantUser.Email,
			CreatedAt: int32(tenantUser.CreatedAt),
			UpdatedAt: int32(tenantUser.UpdatedAt),
		},
	}, nil
}

// RemoveUserFromTenant is the resolver for the removeUserFromTenant field.
func (r *mutationResolver) RemoveUserFromTenant(ctx context.Context, userID string, tenantID string) (*model.DeleteTenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	parsedUserID, err := strconv.ParseInt(userID, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	parsedTenantID, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.RemoveUserFromTenant(ctx, &tenantPb.RemoveUserFromTenantRequest{
		UserId:   parsedUserID,
		TenantId: parsedTenantID,
	})
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to remove user from tenant: %v", err),
		}, nil
	}

	return &model.DeleteTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, input model.UpdateUserRoleInput) (*model.UpdateUserRoleResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.UpdateUserRole(ctx, &tenantPb.UpdateUserRoleRequest{
		UserId:   userID,
		TenantId: tenantID,
		Role:     input.Role,
	})
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to update user role: %v", err),
		}, nil
	}

	return &model.UpdateUserRoleResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// SetDefaultTenant is the resolver for the setDefaultTenant field.
func (r *mutationResolver) SetDefaultTenant(ctx context.Context, input model.SetDefaultTenantInput) (*model.SetDefaultTenantResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.SetDefaultTenant(ctx, &tenantPb.SetDefaultTenantRequest{
		UserId:   userID,
		TenantId: tenantID,
	})
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to set default tenant: %v", err),
		}, nil
	}

	return &model.SetDefaultTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// SetTenantSetting is the resolver for the setTenantSetting field.
func (r *mutationResolver) SetTenantSetting(ctx context.Context, input model.SetSettingInput) (*model.TenantSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.SetSetting(ctx, &tenantPb.SetSettingRequest{
		TenantId: tenantID,
		Key:      input.Key,
		Value:    input.Value,
	})
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to set tenant setting: %v", err),
		}, nil
	}

	if !resp.Success || resp.Data == nil {
		return &model.TenantSettingResponse{
			Success: resp.Success,
			Message: resp.Message,
		}, nil
	}

	setting := resp.Data
	return &model.TenantSettingResponse{
		Success: true,
		Message: "Tenant setting saved successfully",
		Data: &model.TenantSetting{
			ID:        strconv.FormatInt(setting.Id, 10),
			TenantID:  strconv.FormatInt(setting.TenantId, 10),
			Key:       setting.Key,
			Value:     setting.Value,
			CreatedAt: int32(setting.CreatedAt),
			UpdatedAt: int32(setting.UpdatedAt),
		},
	}, nil
}

// DeleteTenantSetting is the resolver for the deleteTenantSetting field.
func (r *mutationResolver) DeleteTenantSetting(ctx context.Context, tenantID string, key string) (*model.DeleteSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.DeleteSetting(ctx, &tenantPb.DeleteSettingRequest{
		TenantId: tenantIDInt,
		Key:      key,
	})
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to delete tenant setting: %v", err),
		}, nil
	}

	return &model.DeleteSettingResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.ProductResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Prepare request with optional fields
	req := &productPb.CreateProductRequest{
		Name: input.Name,
	}
	if input.Slug != nil {
		req.Slug = *input.Slug
	}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.Metadata != nil {
		req.Metadata = *input.Metadata
	}
	if input.Features != nil {
		req.Features = *input.Features
	}
	if input.IsPopular != nil {
		req.IsPopular = *input.IsPopular
	}
	if input.IsDefault != nil {
		req.IsDefault = *input.IsDefault
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.CreateProduct(ctx, req)
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: fmt.Sprintf("Create product failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ProductResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto product to GraphQL model
	product := resp.Data
	return &model.ProductResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Product{
			ID:          strconv.FormatInt(product.Id, 10),
			Name:        product.Name,
			Slug:        product.Slug,
			Description: &product.Description,
			Metadata:    &product.Metadata,
			Features:    &product.Features,
			IsPopular:   product.IsPopular,
			IsDefault:   product.IsDefault,
			CreatedAt:   int32(product.CreatedAt),
			UpdatedAt:   int32(product.UpdatedAt),
		},
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input model.UpdateProductInput) (*model.ProductResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse product ID
	productID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: "Invalid product ID",
		}, nil
	}

	// Prepare request
	req := &productPb.UpdateProductRequest{
		Id:   productID,
		Name: input.Name,
	}
	if input.Slug != nil {
		req.Slug = *input.Slug
	}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.Metadata != nil {
		req.Metadata = *input.Metadata
	}
	if input.Features != nil {
		req.Features = *input.Features
	}
	if input.IsPopular != nil {
		req.IsPopular = *input.IsPopular
	}
	if input.IsDefault != nil {
		req.IsDefault = *input.IsDefault
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.UpdateProduct(ctx, req)
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: fmt.Sprintf("Update product failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ProductResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto product to GraphQL model
	product := resp.Data
	return &model.ProductResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Product{
			ID:          strconv.FormatInt(product.Id, 10),
			Name:        product.Name,
			Slug:        product.Slug,
			Description: &product.Description,
			Metadata:    &product.Metadata,
			Features:    &product.Features,
			IsPopular:   product.IsPopular,
			IsDefault:   product.IsDefault,
			CreatedAt:   int32(product.CreatedAt),
			UpdatedAt:   int32(product.UpdatedAt),
		},
	}, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (*model.DeleteProductResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.DeleteProductResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse product ID
	productID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteProductResponse{
			Success: false,
			Message: "Invalid product ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.DeleteProduct(ctx, &productPb.DeleteProductRequest{
		Id: productID,
	})
	if err != nil {
		return &model.DeleteProductResponse{
			Success: false,
			Message: fmt.Sprintf("Delete product failed: %v", err),
		}, nil
	}

	return &model.DeleteProductResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// CreatePlan is the resolver for the createPlan field.
func (r *mutationResolver) CreatePlan(ctx context.Context, input model.CreatePlanInput) (*model.PlanResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse IDs
	intervalID, err := strconv.ParseInt(input.IntervalID, 10, 64)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Invalid interval ID",
		}, nil
	}

	productID, err := strconv.ParseInt(input.ProductID, 10, 64)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Invalid product ID",
		}, nil
	}

	// Prepare request
	req := &productPb.CreatePlanRequest{
		Name:          input.Name,
		IntervalId:    intervalID,
		ProductId:     productID,
		IntervalCount: input.IntervalCount,
		Type:          input.Type,
	}

	if input.Slug != nil {
		req.Slug = *input.Slug
	}
	if input.IsActive != nil {
		req.IsActive = *input.IsActive
	} else {
		req.IsActive = true
	}
	if input.HasTrial != nil {
		req.HasTrial = *input.HasTrial
	}
	if input.TrialIntervalID != nil {
		trialIntervalID, err := strconv.ParseInt(*input.TrialIntervalID, 10, 64)
		if err == nil {
			req.TrialIntervalId = &trialIntervalID
		}
	}
	if input.TrialIntervalCount != nil {
		req.TrialIntervalCount = *input.TrialIntervalCount
	}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.MaxUsersPerTenant != nil {
		req.MaxUsersPerTenant = *input.MaxUsersPerTenant
	}
	if input.MeterID != nil {
		meterID, err := strconv.ParseInt(*input.MeterID, 10, 64)
		if err == nil {
			req.MeterId = &meterID
		}
	}
	if input.IsVisible != nil {
		req.IsVisible = *input.IsVisible
	} else {
		req.IsVisible = true
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.CreatePlan(ctx, req)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: fmt.Sprintf("Create plan failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlanResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto plan to GraphQL model
	plan := resp.Data
	return &model.PlanResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Plan{
			ID:         strconv.FormatInt(plan.Id, 10),
			Name:       plan.Name,
			Slug:       plan.Slug,
			IntervalID: strconv.FormatInt(plan.IntervalId, 10),
			ProductID:  strconv.FormatInt(plan.ProductId, 10),
			IsActive:   plan.IsActive,
			HasTrial:   plan.HasTrial,
			TrialIntervalID: func() *string {
				if plan.TrialIntervalId != nil {
					s := strconv.FormatInt(*plan.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      plan.IntervalCount,
			TrialIntervalCount: &plan.TrialIntervalCount,
			Description:        &plan.Description,
			Type:               plan.Type,
			MaxUsersPerTenant:  &plan.MaxUsersPerTenant,
			MeterID: func() *string {
				if plan.MeterId != nil {
					s := strconv.FormatInt(*plan.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: plan.IsVisible,
			CreatedAt: int32(plan.CreatedAt),
			UpdatedAt: int32(plan.UpdatedAt),
		},
	}, nil
}

// UpdatePlan is the resolver for the updatePlan field.
func (r *mutationResolver) UpdatePlan(ctx context.Context, input model.UpdatePlanInput) (*model.PlanResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse IDs
	planID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Invalid plan ID",
		}, nil
	}

	intervalID, err := strconv.ParseInt(input.IntervalID, 10, 64)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Invalid interval ID",
		}, nil
	}

	// Prepare request
	req := &productPb.UpdatePlanRequest{
		Id:            planID,
		Name:          input.Name,
		IntervalId:    intervalID,
		IntervalCount: input.IntervalCount,
		Type:          input.Type,
	}

	if input.Slug != nil {
		req.Slug = *input.Slug
	}
	if input.IsActive != nil {
		req.IsActive = *input.IsActive
	}
	if input.HasTrial != nil {
		req.HasTrial = *input.HasTrial
	}
	if input.TrialIntervalID != nil {
		trialIntervalID, err := strconv.ParseInt(*input.TrialIntervalID, 10, 64)
		if err == nil {
			req.TrialIntervalId = &trialIntervalID
		}
	}
	if input.TrialIntervalCount != nil {
		req.TrialIntervalCount = *input.TrialIntervalCount
	}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.MaxUsersPerTenant != nil {
		req.MaxUsersPerTenant = *input.MaxUsersPerTenant
	}
	if input.MeterID != nil {
		meterID, err := strconv.ParseInt(*input.MeterID, 10, 64)
		if err == nil {
			req.MeterId = &meterID
		}
	}
	if input.IsVisible != nil {
		req.IsVisible = *input.IsVisible
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.UpdatePlan(ctx, req)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: fmt.Sprintf("Update plan failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlanResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto plan to GraphQL model
	plan := resp.Data
	return &model.PlanResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Plan{
			ID:         strconv.FormatInt(plan.Id, 10),
			Name:       plan.Name,
			Slug:       plan.Slug,
			IntervalID: strconv.FormatInt(plan.IntervalId, 10),
			ProductID:  strconv.FormatInt(plan.ProductId, 10),
			IsActive:   plan.IsActive,
			HasTrial:   plan.HasTrial,
			TrialIntervalID: func() *string {
				if plan.TrialIntervalId != nil {
					s := strconv.FormatInt(*plan.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      plan.IntervalCount,
			TrialIntervalCount: &plan.TrialIntervalCount,
			Description:        &plan.Description,
			Type:               plan.Type,
			MaxUsersPerTenant:  &plan.MaxUsersPerTenant,
			MeterID: func() *string {
				if plan.MeterId != nil {
					s := strconv.FormatInt(*plan.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: plan.IsVisible,
			CreatedAt: int32(plan.CreatedAt),
			UpdatedAt: int32(plan.UpdatedAt),
		},
	}, nil
}

// DeletePlan is the resolver for the deletePlan field.
func (r *mutationResolver) DeletePlan(ctx context.Context, id string) (*model.DeletePlanResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.DeletePlanResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse plan ID
	planID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeletePlanResponse{
			Success: false,
			Message: "Invalid plan ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.DeletePlan(ctx, &productPb.DeletePlanRequest{
		Id: planID,
	})
	if err != nil {
		return &model.DeletePlanResponse{
			Success: false,
			Message: fmt.Sprintf("Delete plan failed: %v", err),
		}, nil
	}

	return &model.DeletePlanResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// CreateDiscount is the resolver for the createDiscount field.
func (r *mutationResolver) CreateDiscount(ctx context.Context, input model.CreateDiscountInput) (*model.DiscountResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Prepare request
	req := &productPb.CreateDiscountRequest{
		Name:        input.Name,
		Type:        input.Type,
		Amount:      input.Amount,
		IsActive:    input.IsActive,
		IsRecurring: input.IsRecurring,
	}

	// Handle optional fields
	if input.Description != nil {
		req.Description = input.Description
	}
	if input.ValidUntil != nil {
		validUntil := int64(*input.ValidUntil)
		req.ValidUntil = &validUntil
	}
	if input.ActionType != nil {
		req.ActionType = input.ActionType
	}
	if input.MaxRedemptions != nil {
		maxRedemptions := int32(*input.MaxRedemptions)
		req.MaxRedemptions = &maxRedemptions
	}
	if input.MaxRedemptionsPerUser != nil {
		maxRedemptionsPerUser := int32(*input.MaxRedemptionsPerUser)
		req.MaxRedemptionsPerUser = &maxRedemptionsPerUser
	}
	if input.DurationInMonths != nil {
		durationInMonths := int32(*input.DurationInMonths)
		req.DurationInMonths = &durationInMonths
	}
	if input.MaximumRecurringIntervals != nil {
		maximumRecurringIntervals := int32(*input.MaximumRecurringIntervals)
		req.MaximumRecurringIntervals = &maximumRecurringIntervals
	}
	if input.RedeemType != nil {
		redeemType := int32(*input.RedeemType)
		req.RedeemType = &redeemType
	}
	if input.BonusDays != nil {
		bonusDays := int32(*input.BonusDays)
		req.BonusDays = &bonusDays
	}
	if input.IsEnabledForAllPlans != nil {
		req.IsEnabledForAllPlans = *input.IsEnabledForAllPlans
	}
	if input.IsEnabledForAllOneTimeProducts != nil {
		req.IsEnabledForAllOneTimeProducts = *input.IsEnabledForAllOneTimeProducts
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.CreateDiscount(ctx, req)
	if err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: fmt.Sprintf("Create discount failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DiscountResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto discount to GraphQL model
	discount := resp.Data
	return &model.DiscountResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Discount{
			ID:          strconv.FormatInt(discount.Id, 10),
			Name:        discount.Name,
			Description: discount.Description,
			Type:        discount.Type,
			Amount:      discount.Amount,
			ValidUntil: func() *int32 {
				if discount.ValidUntil != nil {
					v := int32(*discount.ValidUntil)
					return &v
				}
				return nil
			}(),
			IsActive:   discount.IsActive,
			ActionType: discount.ActionType,
			MaxRedemptions: func() *int32 {
				if discount.MaxRedemptions != nil {
					v := int32(*discount.MaxRedemptions)
					return &v
				}
				return nil
			}(),
			MaxRedemptionsPerUser: func() *int32 {
				if discount.MaxRedemptionsPerUser != nil {
					v := int32(*discount.MaxRedemptionsPerUser)
					return &v
				}
				return nil
			}(),
			Redemptions: int32(discount.Redemptions),
			IsRecurring: discount.IsRecurring,
			DurationInMonths: func() *int32 {
				if discount.DurationInMonths != nil {
					v := int32(*discount.DurationInMonths)
					return &v
				}
				return nil
			}(),
			MaximumRecurringIntervals: func() *int32 {
				if discount.MaximumRecurringIntervals != nil {
					v := int32(*discount.MaximumRecurringIntervals)
					return &v
				}
				return nil
			}(),
			RedeemType: func() *int32 {
				if discount.RedeemType != nil {
					v := int32(*discount.RedeemType)
					return &v
				}
				return nil
			}(),
			BonusDays: func() *int32 {
				if discount.BonusDays != nil {
					v := int32(*discount.BonusDays)
					return &v
				}
				return nil
			}(),
			IsEnabledForAllPlans:           discount.IsEnabledForAllPlans,
			IsEnabledForAllOneTimeProducts: discount.IsEnabledForAllOneTimeProducts,
			CreatedAt:                      int32(discount.CreatedAt),
			UpdatedAt:                      int32(discount.UpdatedAt),
		},
	}, nil
}

// UpdateDiscount is the resolver for the updateDiscount field.
func (r *mutationResolver) UpdateDiscount(ctx context.Context, input model.UpdateDiscountInput) (*model.DiscountResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse ID
	discountID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: "Invalid discount ID",
		}, nil
	}

	// Prepare request
	req := &productPb.UpdateDiscountRequest{
		Id:          discountID,
		Name:        input.Name,
		Type:        input.Type,
		Amount:      input.Amount,
		IsActive:    input.IsActive,
		IsRecurring: input.IsRecurring,
	}

	// Handle optional fields
	if input.Description != nil {
		req.Description = input.Description
	}
	if input.ValidUntil != nil {
		validUntil := int64(*input.ValidUntil)
		req.ValidUntil = &validUntil
	}
	if input.ActionType != nil {
		req.ActionType = input.ActionType
	}
	if input.MaxRedemptions != nil {
		maxRedemptions := int32(*input.MaxRedemptions)
		req.MaxRedemptions = &maxRedemptions
	}
	if input.MaxRedemptionsPerUser != nil {
		maxRedemptionsPerUser := int32(*input.MaxRedemptionsPerUser)
		req.MaxRedemptionsPerUser = &maxRedemptionsPerUser
	}
	if input.DurationInMonths != nil {
		durationInMonths := int32(*input.DurationInMonths)
		req.DurationInMonths = &durationInMonths
	}
	if input.MaximumRecurringIntervals != nil {
		maximumRecurringIntervals := int32(*input.MaximumRecurringIntervals)
		req.MaximumRecurringIntervals = &maximumRecurringIntervals
	}
	if input.RedeemType != nil {
		redeemType := int32(*input.RedeemType)
		req.RedeemType = &redeemType
	}
	if input.BonusDays != nil {
		bonusDays := int32(*input.BonusDays)
		req.BonusDays = &bonusDays
	}
	if input.IsEnabledForAllPlans != nil {
		req.IsEnabledForAllPlans = *input.IsEnabledForAllPlans
	}
	if input.IsEnabledForAllOneTimeProducts != nil {
		req.IsEnabledForAllOneTimeProducts = *input.IsEnabledForAllOneTimeProducts
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.UpdateDiscount(ctx, req)
	if err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: fmt.Sprintf("Update discount failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DiscountResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto discount to GraphQL model
	discount := resp.Data
	return &model.DiscountResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Discount{
			ID:          strconv.FormatInt(discount.Id, 10),
			Name:        discount.Name,
			Description: discount.Description,
			Type:        discount.Type,
			Amount:      discount.Amount,
			ValidUntil: func() *int32 {
				if discount.ValidUntil != nil {
					v := int32(*discount.ValidUntil)
					return &v
				}
				return nil
			}(),
			IsActive:   discount.IsActive,
			ActionType: discount.ActionType,
			MaxRedemptions: func() *int32 {
				if discount.MaxRedemptions != nil {
					v := int32(*discount.MaxRedemptions)
					return &v
				}
				return nil
			}(),
			MaxRedemptionsPerUser: func() *int32 {
				if discount.MaxRedemptionsPerUser != nil {
					v := int32(*discount.MaxRedemptionsPerUser)
					return &v
				}
				return nil
			}(),
			Redemptions: int32(discount.Redemptions),
			IsRecurring: discount.IsRecurring,
			DurationInMonths: func() *int32 {
				if discount.DurationInMonths != nil {
					v := int32(*discount.DurationInMonths)
					return &v
				}
				return nil
			}(),
			MaximumRecurringIntervals: func() *int32 {
				if discount.MaximumRecurringIntervals != nil {
					v := int32(*discount.MaximumRecurringIntervals)
					return &v
				}
				return nil
			}(),
			RedeemType: func() *int32 {
				if discount.RedeemType != nil {
					v := int32(*discount.RedeemType)
					return &v
				}
				return nil
			}(),
			BonusDays: func() *int32 {
				if discount.BonusDays != nil {
					v := int32(*discount.BonusDays)
					return &v
				}
				return nil
			}(),
			IsEnabledForAllPlans:           discount.IsEnabledForAllPlans,
			IsEnabledForAllOneTimeProducts: discount.IsEnabledForAllOneTimeProducts,
			CreatedAt:                      int32(discount.CreatedAt),
			UpdatedAt:                      int32(discount.UpdatedAt),
		},
	}, nil
}

// DeleteDiscount is the resolver for the deleteDiscount field.
func (r *mutationResolver) DeleteDiscount(ctx context.Context, id string) (*model.DeleteDiscountResponse, error) {
	// Admin only
	if err := middleware.RequireAdmin(ctx); err != nil {
		return &model.DeleteDiscountResponse{
			Success: false,
			Message: "Admin access required",
		}, nil
	}

	// Parse ID
	discountID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteDiscountResponse{
			Success: false,
			Message: "Invalid discount ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.DeleteDiscount(ctx, &productPb.DeleteDiscountRequest{
		Id: discountID,
	})
	if err != nil {
		return &model.DeleteDiscountResponse{
			Success: false,
			Message: fmt.Sprintf("Delete discount failed: %v", err),
		}, nil
	}

	return &model.DeleteDiscountResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.UserResponse, error) {
	userID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: userID,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetAllUsers(ctx, &userPb.GetAllUsersRequest{
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Get users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users retrieved successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.SearchUsers(ctx, &userPb.SearchUsersRequest{
		Query:   query,
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Search users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users search completed successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user details from user-service
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get current user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "Current user retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// VerifyResetToken is the resolver for the verifyResetToken field.
func (r *queryResolver) VerifyResetToken(ctx context.Context, token string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyResetToken(ctx, &authPb.VerifyResetTokenRequest{
		Token: token,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Verify reset token failed: %v", err),
		}, nil
	}

	if !resp.Valid {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Reset token is valid",
	}, nil
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context, id string) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantByID(ctx, &tenantPb.GetTenantByIDRequest{
		Id: tenantID,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant retrieved successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// TenantBySlug is the resolver for the tenantBySlug field.
func (r *queryResolver) TenantBySlug(ctx context.Context, slug string) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantBySlug(ctx, &tenantPb.GetTenantBySlugRequest{
		Slug: slug,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant retrieved successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// Tenants is the resolver for the tenants field.
func (r *queryResolver) Tenants(ctx context.Context, page *int32, perPage *int32) (*model.TenantListResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantListResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Set default pagination
	pageValue := int32(1)
	perPageValue := int32(10)
	if page != nil {
		pageValue = *page
	}
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetAllTenants(ctx, &tenantPb.GetAllTenantsRequest{
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.TenantListResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenants: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert tenants
	tenants := make([]*model.Tenant, len(resp.Data.Tenants))
	for i, t := range resp.Data.Tenants {
		tenants[i] = &model.Tenant{
			ID:                  strconv.FormatInt(t.Id, 10),
			UUID:                t.Uuid,
			Name:                t.Name,
			Slug:                t.Slug,
			Domain:              util.StringPtr(t.Domain),
			IsNameAutoGenerated: t.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(t.CreatedBy, 10),
			CreatedAt:           int32(t.CreatedAt),
			UpdatedAt:           int32(t.UpdatedAt),
		}
	}

	return &model.TenantListResponse{
		Success: true,
		Message: "Tenants retrieved successfully",
		Data: &model.TenantList{
			Tenants: tenants,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// TenantUsers is the resolver for the tenantUsers field.
func (r *queryResolver) TenantUsers(ctx context.Context, tenantID string) (*model.TenantUsersResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	parsedTenantID, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantUsers(ctx, &tenantPb.GetTenantUsersRequest{
		TenantId: parsedTenantID,
	})
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant users: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUsersResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert tenant users
	tenantUsers := make([]*model.TenantUser, len(resp.Data))
	for i, tu := range resp.Data {
		tenantUsers[i] = &model.TenantUser{
			ID:        strconv.FormatInt(tu.Id, 10),
			UserID:    strconv.FormatInt(tu.UserId, 10),
			TenantID:  strconv.FormatInt(tu.TenantId, 10),
			Role:      tu.Role,
			IsDefault: tu.IsDefault,
			Email:     tu.Email,
			CreatedAt: int32(tu.CreatedAt),
			UpdatedAt: int32(tu.UpdatedAt),
		}
	}

	return &model.TenantUsersResponse{
		Success: true,
		Message: "Tenant users retrieved successfully",
		Data:    tenantUsers,
	}, nil
}

// UserTenants is the resolver for the userTenants field.
func (r *queryResolver) UserTenants(ctx context.Context, userID string) (*model.TenantUsersResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userIDInt, err := strconv.ParseInt(userID, 10, 64)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	resp, err := r.TenantClient.GetUserTenants(ctx, &tenantPb.GetUserTenantsRequest{
		UserId: userIDInt,
	})
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get user tenants: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUsersResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	var tenantUsers []*model.TenantUser
	for _, tu := range resp.Data {
		tenantUsers = append(tenantUsers, &model.TenantUser{
			ID:        strconv.FormatInt(tu.Id, 10),
			UserID:    strconv.FormatInt(tu.UserId, 10),
			TenantID:  strconv.FormatInt(tu.TenantId, 10),
			Role:      tu.Role,
			IsDefault: tu.IsDefault,
			Email:     tu.Email,
			CreatedAt: int32(tu.CreatedAt),
			UpdatedAt: int32(tu.UpdatedAt),
		})
	}

	return &model.TenantUsersResponse{
		Success: true,
		Message: "User tenants retrieved successfully",
		Data:    tenantUsers,
	}, nil
}

// TenantSetting is the resolver for the tenantSetting field.
func (r *queryResolver) TenantSetting(ctx context.Context, tenantID string, key string) (*model.TenantSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.GetSetting(ctx, &tenantPb.GetSettingRequest{
		TenantId: tenantIDInt,
		Key:      key,
	})
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant setting: %v", err),
		}, nil
	}

	if !resp.Success || resp.Data == nil {
		return &model.TenantSettingResponse{
			Success: resp.Success,
			Message: resp.Message,
		}, nil
	}

	setting := resp.Data
	return &model.TenantSettingResponse{
		Success: true,
		Message: "Tenant setting retrieved successfully",
		Data: &model.TenantSetting{
			ID:        strconv.FormatInt(setting.Id, 10),
			TenantID:  strconv.FormatInt(setting.TenantId, 10),
			Key:       setting.Key,
			Value:     setting.Value,
			CreatedAt: int32(setting.CreatedAt),
			UpdatedAt: int32(setting.UpdatedAt),
		},
	}, nil
}

// TenantSettings is the resolver for the tenantSettings field.
func (r *queryResolver) TenantSettings(ctx context.Context, tenantID string) (*model.TenantSettingsResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.GetAllSettings(ctx, &tenantPb.GetAllSettingsRequest{
		TenantId: tenantIDInt,
	})
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant settings: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	var settings []*model.TenantSetting
	for _, s := range resp.Data {
		settings = append(settings, &model.TenantSetting{
			ID:        strconv.FormatInt(s.Id, 10),
			TenantID:  strconv.FormatInt(s.TenantId, 10),
			Key:       s.Key,
			Value:     s.Value,
			CreatedAt: int32(s.CreatedAt),
			UpdatedAt: int32(s.UpdatedAt),
		})
	}

	return &model.TenantSettingsResponse{
		Success: true,
		Message: "Tenant settings retrieved successfully",
		Data:    settings,
	}, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.ProductResponse, error) {
	productID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: "Invalid product ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetProductByID(ctx, &productPb.GetProductByIDRequest{
		Id: productID,
	})
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: fmt.Sprintf("Get product failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ProductResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	product := resp.Data
	return &model.ProductResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Product{
			ID:          strconv.FormatInt(product.Id, 10),
			Name:        product.Name,
			Slug:        product.Slug,
			Description: &product.Description,
			Metadata:    &product.Metadata,
			Features:    &product.Features,
			IsPopular:   product.IsPopular,
			IsDefault:   product.IsDefault,
			CreatedAt:   int32(product.CreatedAt),
			UpdatedAt:   int32(product.UpdatedAt),
		},
	}, nil
}

// ProductBySlug is the resolver for the productBySlug field.
func (r *queryResolver) ProductBySlug(ctx context.Context, slug string) (*model.ProductResponse, error) {
	// Call product-service via gRPC
	resp, err := r.ProductClient.GetProductBySlug(ctx, &productPb.GetProductBySlugRequest{
		Slug: slug,
	})
	if err != nil {
		return &model.ProductResponse{
			Success: false,
			Message: fmt.Sprintf("Get product failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ProductResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	product := resp.Data
	return &model.ProductResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Product{
			ID:          strconv.FormatInt(product.Id, 10),
			Name:        product.Name,
			Slug:        product.Slug,
			Description: &product.Description,
			Metadata:    &product.Metadata,
			Features:    &product.Features,
			IsPopular:   product.IsPopular,
			IsDefault:   product.IsDefault,
			CreatedAt:   int32(product.CreatedAt),
			UpdatedAt:   int32(product.UpdatedAt),
		},
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, page *int32, perPage *int32) (*model.ProductListResponse, error) {
	// Set default pagination
	pageNum := int32(1)
	pageSize := int32(10)
	if page != nil && *page > 0 {
		pageNum = *page
	}
	if perPage != nil && *perPage > 0 {
		pageSize = *perPage
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetAllProducts(ctx, &productPb.GetAllProductsRequest{
		Page:    pageNum,
		PerPage: pageSize,
	})
	if err != nil {
		return &model.ProductListResponse{
			Success: false,
			Message: fmt.Sprintf("Get products failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ProductListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert products
	products := make([]*model.Product, len(resp.Data.Products))
	for i, p := range resp.Data.Products {
		products[i] = &model.Product{
			ID:          strconv.FormatInt(p.Id, 10),
			Name:        p.Name,
			Slug:        p.Slug,
			Description: &p.Description,
			Metadata:    &p.Metadata,
			Features:    &p.Features,
			IsPopular:   p.IsPopular,
			IsDefault:   p.IsDefault,
			CreatedAt:   int32(p.CreatedAt),
			UpdatedAt:   int32(p.UpdatedAt),
		}
	}

	return &model.ProductListResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.ProductList{
			Products: products,
			Total:    resp.Data.Total,
			Page:     resp.Data.Page,
			PerPage:  resp.Data.PerPage,
		},
	}, nil
}

// Plan is the resolver for the plan field.
func (r *queryResolver) Plan(ctx context.Context, id string) (*model.PlanResponse, error) {
	planID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: "Invalid plan ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetPlanByID(ctx, &productPb.GetPlanByIDRequest{
		Id: planID,
	})
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: fmt.Sprintf("Get plan failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlanResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	plan := resp.Data
	return &model.PlanResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Plan{
			ID:         strconv.FormatInt(plan.Id, 10),
			Name:       plan.Name,
			Slug:       plan.Slug,
			IntervalID: strconv.FormatInt(plan.IntervalId, 10),
			ProductID:  strconv.FormatInt(plan.ProductId, 10),
			IsActive:   plan.IsActive,
			HasTrial:   plan.HasTrial,
			TrialIntervalID: func() *string {
				if plan.TrialIntervalId != nil {
					s := strconv.FormatInt(*plan.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      plan.IntervalCount,
			TrialIntervalCount: &plan.TrialIntervalCount,
			Description:        &plan.Description,
			Type:               plan.Type,
			MaxUsersPerTenant:  &plan.MaxUsersPerTenant,
			MeterID: func() *string {
				if plan.MeterId != nil {
					s := strconv.FormatInt(*plan.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: plan.IsVisible,
			CreatedAt: int32(plan.CreatedAt),
			UpdatedAt: int32(plan.UpdatedAt),
		},
	}, nil
}

// PlanBySlug is the resolver for the planBySlug field.
func (r *queryResolver) PlanBySlug(ctx context.Context, slug string) (*model.PlanResponse, error) {
	// Call product-service via gRPC
	resp, err := r.ProductClient.GetPlanBySlug(ctx, &productPb.GetPlanBySlugRequest{
		Slug: slug,
	})
	if err != nil {
		return &model.PlanResponse{
			Success: false,
			Message: fmt.Sprintf("Get plan failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlanResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	plan := resp.Data
	return &model.PlanResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Plan{
			ID:         strconv.FormatInt(plan.Id, 10),
			Name:       plan.Name,
			Slug:       plan.Slug,
			IntervalID: strconv.FormatInt(plan.IntervalId, 10),
			ProductID:  strconv.FormatInt(plan.ProductId, 10),
			IsActive:   plan.IsActive,
			HasTrial:   plan.HasTrial,
			TrialIntervalID: func() *string {
				if plan.TrialIntervalId != nil {
					s := strconv.FormatInt(*plan.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      plan.IntervalCount,
			TrialIntervalCount: &plan.TrialIntervalCount,
			Description:        &plan.Description,
			Type:               plan.Type,
			MaxUsersPerTenant:  &plan.MaxUsersPerTenant,
			MeterID: func() *string {
				if plan.MeterId != nil {
					s := strconv.FormatInt(*plan.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: plan.IsVisible,
			CreatedAt: int32(plan.CreatedAt),
			UpdatedAt: int32(plan.UpdatedAt),
		},
	}, nil
}

// Plans is the resolver for the plans field.
func (r *queryResolver) Plans(ctx context.Context, page *int32, perPage *int32, activeOnly *bool, visibleOnly *bool) (*model.PlanListResponse, error) {
	// Set default pagination
	pageNum := int32(1)
	pageSize := int32(10)
	if page != nil && *page > 0 {
		pageNum = *page
	}
	if perPage != nil && *perPage > 0 {
		pageSize = *perPage
	}

	// Prepare filters
	req := &productPb.GetAllPlansRequest{
		Page:    pageNum,
		PerPage: pageSize,
	}
	if activeOnly != nil {
		req.ActiveOnly = *activeOnly
	}
	if visibleOnly != nil {
		req.VisibleOnly = *visibleOnly
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetAllPlans(ctx, req)
	if err != nil {
		return &model.PlanListResponse{
			Success: false,
			Message: fmt.Sprintf("Get plans failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlanListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert plans
	plans := make([]*model.Plan, len(resp.Data.Plans))
	for i, p := range resp.Data.Plans {
		plans[i] = &model.Plan{
			ID:         strconv.FormatInt(p.Id, 10),
			Name:       p.Name,
			Slug:       p.Slug,
			IntervalID: strconv.FormatInt(p.IntervalId, 10),
			ProductID:  strconv.FormatInt(p.ProductId, 10),
			IsActive:   p.IsActive,
			HasTrial:   p.HasTrial,
			TrialIntervalID: func() *string {
				if p.TrialIntervalId != nil {
					s := strconv.FormatInt(*p.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      p.IntervalCount,
			TrialIntervalCount: &p.TrialIntervalCount,
			Description:        &p.Description,
			Type:               p.Type,
			MaxUsersPerTenant:  &p.MaxUsersPerTenant,
			MeterID: func() *string {
				if p.MeterId != nil {
					s := strconv.FormatInt(*p.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: p.IsVisible,
			CreatedAt: int32(p.CreatedAt),
			UpdatedAt: int32(p.UpdatedAt),
		}
	}

	return &model.PlanListResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.PlanList{
			Plans:   plans,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// PlansByProduct is the resolver for the plansByProduct field.
func (r *queryResolver) PlansByProduct(ctx context.Context, productID string) (*model.PlansResponse, error) {
	productIDInt, err := strconv.ParseInt(productID, 10, 64)
	if err != nil {
		return &model.PlansResponse{
			Success: false,
			Message: "Invalid product ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetPlansByProduct(ctx, &productPb.GetPlansByProductRequest{
		ProductId: productIDInt,
	})
	if err != nil {
		return &model.PlansResponse{
			Success: false,
			Message: fmt.Sprintf("Get plans failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.PlansResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert plans
	plans := make([]*model.Plan, len(resp.Data))
	for i, p := range resp.Data {
		plans[i] = &model.Plan{
			ID:         strconv.FormatInt(p.Id, 10),
			Name:       p.Name,
			Slug:       p.Slug,
			IntervalID: strconv.FormatInt(p.IntervalId, 10),
			ProductID:  strconv.FormatInt(p.ProductId, 10),
			IsActive:   p.IsActive,
			HasTrial:   p.HasTrial,
			TrialIntervalID: func() *string {
				if p.TrialIntervalId != nil {
					s := strconv.FormatInt(*p.TrialIntervalId, 10)
					return &s
				}
				return nil
			}(),
			IntervalCount:      p.IntervalCount,
			TrialIntervalCount: &p.TrialIntervalCount,
			Description:        &p.Description,
			Type:               p.Type,
			MaxUsersPerTenant:  &p.MaxUsersPerTenant,
			MeterID: func() *string {
				if p.MeterId != nil {
					s := strconv.FormatInt(*p.MeterId, 10)
					return &s
				}
				return nil
			}(),
			IsVisible: p.IsVisible,
			CreatedAt: int32(p.CreatedAt),
			UpdatedAt: int32(p.UpdatedAt),
		}
	}

	return &model.PlansResponse{
		Success: true,
		Message: resp.Message,
		Data:    plans,
	}, nil
}

// Discount is the resolver for the discount field.
func (r *queryResolver) Discount(ctx context.Context, id string) (*model.DiscountResponse, error) {
	// Parse ID
	discountID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: "Invalid discount ID",
		}, nil
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetDiscountByID(ctx, &productPb.GetDiscountByIDRequest{
		Id: discountID,
	})
	if err != nil {
		return &model.DiscountResponse{
			Success: false,
			Message: fmt.Sprintf("Get discount failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DiscountResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto discount to GraphQL model
	discount := resp.Data
	return &model.DiscountResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.Discount{
			ID:          strconv.FormatInt(discount.Id, 10),
			Name:        discount.Name,
			Description: discount.Description,
			Type:        discount.Type,
			Amount:      discount.Amount,
			ValidUntil: func() *int32 {
				if discount.ValidUntil != nil {
					v := int32(*discount.ValidUntil)
					return &v
				}
				return nil
			}(),
			IsActive:   discount.IsActive,
			ActionType: discount.ActionType,
			MaxRedemptions: func() *int32 {
				if discount.MaxRedemptions != nil {
					v := int32(*discount.MaxRedemptions)
					return &v
				}
				return nil
			}(),
			MaxRedemptionsPerUser: func() *int32 {
				if discount.MaxRedemptionsPerUser != nil {
					v := int32(*discount.MaxRedemptionsPerUser)
					return &v
				}
				return nil
			}(),
			Redemptions: int32(discount.Redemptions),
			IsRecurring: discount.IsRecurring,
			DurationInMonths: func() *int32 {
				if discount.DurationInMonths != nil {
					v := int32(*discount.DurationInMonths)
					return &v
				}
				return nil
			}(),
			MaximumRecurringIntervals: func() *int32 {
				if discount.MaximumRecurringIntervals != nil {
					v := int32(*discount.MaximumRecurringIntervals)
					return &v
				}
				return nil
			}(),
			RedeemType: func() *int32 {
				if discount.RedeemType != nil {
					v := int32(*discount.RedeemType)
					return &v
				}
				return nil
			}(),
			BonusDays: func() *int32 {
				if discount.BonusDays != nil {
					v := int32(*discount.BonusDays)
					return &v
				}
				return nil
			}(),
			IsEnabledForAllPlans:           discount.IsEnabledForAllPlans,
			IsEnabledForAllOneTimeProducts: discount.IsEnabledForAllOneTimeProducts,
			CreatedAt:                      int32(discount.CreatedAt),
			UpdatedAt:                      int32(discount.UpdatedAt),
		},
	}, nil
}

// Discounts is the resolver for the discounts field.
func (r *queryResolver) Discounts(ctx context.Context, page *int32, perPage *int32, activeOnly *bool) (*model.DiscountListResponse, error) {
	// Set defaults
	p := int32(1)
	if page != nil {
		p = *page
	}
	pp := int32(10)
	if perPage != nil {
		pp = *perPage
	}
	ao := false
	if activeOnly != nil {
		ao = *activeOnly
	}

	// Call product-service via gRPC
	resp, err := r.ProductClient.GetAllDiscounts(ctx, &productPb.GetAllDiscountsRequest{
		Page:       p,
		PerPage:    pp,
		ActiveOnly: ao,
	})
	if err != nil {
		return &model.DiscountListResponse{
			Success: false,
			Message: fmt.Sprintf("Get discounts failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DiscountListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert proto discounts to GraphQL models
	discounts := make([]*model.Discount, len(resp.Data.Discounts))
	for i, d := range resp.Data.Discounts {
		discounts[i] = &model.Discount{
			ID:          strconv.FormatInt(d.Id, 10),
			Name:        d.Name,
			Description: d.Description,
			Type:        d.Type,
			Amount:      d.Amount,
			ValidUntil: func() *int32 {
				if d.ValidUntil != nil {
					v := int32(*d.ValidUntil)
					return &v
				}
				return nil
			}(),
			IsActive:   d.IsActive,
			ActionType: d.ActionType,
			MaxRedemptions: func() *int32 {
				if d.MaxRedemptions != nil {
					v := int32(*d.MaxRedemptions)
					return &v
				}
				return nil
			}(),
			MaxRedemptionsPerUser: func() *int32 {
				if d.MaxRedemptionsPerUser != nil {
					v := int32(*d.MaxRedemptionsPerUser)
					return &v
				}
				return nil
			}(),
			Redemptions: int32(d.Redemptions),
			IsRecurring: d.IsRecurring,
			DurationInMonths: func() *int32 {
				if d.DurationInMonths != nil {
					v := int32(*d.DurationInMonths)
					return &v
				}
				return nil
			}(),
			MaximumRecurringIntervals: func() *int32 {
				if d.MaximumRecurringIntervals != nil {
					v := int32(*d.MaximumRecurringIntervals)
					return &v
				}
				return nil
			}(),
			RedeemType: func() *int32 {
				if d.RedeemType != nil {
					v := int32(*d.RedeemType)
					return &v
				}
				return nil
			}(),
			BonusDays: func() *int32 {
				if d.BonusDays != nil {
					v := int32(*d.BonusDays)
					return &v
				}
				return nil
			}(),
			IsEnabledForAllPlans:           d.IsEnabledForAllPlans,
			IsEnabledForAllOneTimeProducts: d.IsEnabledForAllOneTimeProducts,
			CreatedAt:                      int32(d.CreatedAt),
			UpdatedAt:                      int32(d.UpdatedAt),
		}
	}

	return &model.DiscountListResponse{
		Success: true,
		Message: resp.Message,
		Data: &model.DiscountList{
			Discounts: discounts,
			Total:     int32(resp.Data.Total),
			Page:      resp.Data.Page,
			PerPage:   resp.Data.PerPage,
		},
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type (
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)
