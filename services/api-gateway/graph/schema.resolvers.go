package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"strconv"

	"github.com/damarteplok/damar-admin-cms/services/api-gateway/graph/model"
	"github.com/damarteplok/damar-admin-cms/services/api-gateway/internal/middleware"
	authPb "github.com/damarteplok/damar-admin-cms/shared/proto/auth"
	tenantPb "github.com/damarteplok/damar-admin-cms/shared/proto/tenant"
	userPb "github.com/damarteplok/damar-admin-cms/shared/proto/user"
	"github.com/damarteplok/damar-admin-cms/shared/util"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Login(ctx, &authPb.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: fmt.Sprintf("Login failed: %v", err),
		}, nil
	}

	// Convert proto response to GraphQL model
	if !resp.Success {
		return &model.LoginResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	userData := resp.Data
	emailVerifiedAt := int32(userData.User.EmailVerifiedAt)
	lastLoginAt := int32(userData.User.LastLoginAt)
	createdAt := int32(userData.User.CreatedAt)
	updatedAt := int32(userData.User.UpdatedAt)

	return &model.LoginResponse{
		Success: true,
		Message: "Login successful",
		Data: &model.LoginData{
			AccessToken:  userData.AccessToken,
			RefreshToken: userData.RefreshToken,
			User: &model.User{
				ID:              fmt.Sprintf("%d", userData.User.Id),
				Name:            userData.User.Name,
				Email:           userData.User.Email,
				PublicName:      &userData.User.PublicName,
				IsAdmin:         userData.User.IsAdmin,
				IsBlocked:       userData.User.IsBlocked,
				PhoneNumber:     &userData.User.PhoneNumber,
				Position:        &userData.User.Position,
				EmailVerified:   userData.User.EmailVerified,
				EmailVerifiedAt: &emailVerifiedAt,
				LastLoginAt:     &lastLoginAt,
				CreatedAt:       &createdAt,
				UpdatedAt:       &updatedAt,
			},
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, refreshToken string) (*model.LogoutResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Logout(ctx, &authPb.LogoutRequest{
		RefreshToken: refreshToken,
	})
	if err != nil {
		return &model.LogoutResponse{
			Success: false,
			Message: fmt.Sprintf("Logout failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.LogoutResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.LogoutResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.RefreshTokenResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.RefreshToken(ctx, &authPb.RefreshTokenRequest{
		RefreshToken: input.RefreshToken,
	})
	if err != nil {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: fmt.Sprintf("Refresh token failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.RefreshTokenResponse{
		Success: true,
		Message: "Token refreshed successfully",
		Data: &model.RefreshTokenData{
			AccessToken:  resp.Data.AccessToken,
			RefreshToken: resp.Data.RefreshToken,
		},
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (*model.ChangePasswordResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.ChangePassword(ctx, &authPb.ChangePasswordRequest{
		UserId:      currentUser.Id,
		OldPassword: input.OldPassword,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Change password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ChangePasswordResponse{
		Success: true,
		Message: "Password changed successfully",
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ForgotPassword(ctx, &authPb.ForgotPasswordRequest{
		Email: email,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Forgot password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Password reset email sent successfully",
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ResetPassword(ctx, &authPb.ResetPasswordRequest{
		Token:       input.Token,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Reset password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ResetPasswordResponse{
		Success: true,
		Message: "Password reset successfully",
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (*model.VerifyEmailResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyEmail(ctx, &authPb.VerifyEmailRequest{
		Token: token,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Email verification failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Email verified successfully",
	}, nil
}

// ResendVerificationEmail is the resolver for the resendVerificationEmail field.
func (r *mutationResolver) ResendVerificationEmail(ctx context.Context) (*model.VerifyEmailResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user email from user-service
	userResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !userResp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: "Failed to get user information",
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: currentUser.Id,
		Email:  userResp.Data.Email,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Resend verification email failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Verification email sent successfully",
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserResponse, error) {
	// Public registration - no auth check needed
	isAdmin := false
	if input.IsAdmin != nil {
		isAdmin = *input.IsAdmin
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.CreateUser(ctx, &userPb.CreateUserRequest{
		Name:        input.Name,
		Email:       input.Email,
		Password:    input.Password,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdmin,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Create user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Generate verification token after user creation
	verifyResp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: resp.Data.Id,
		Email:  resp.Data.Email,
	})
	if err != nil || !verifyResp.Success {
		// Log error but don't fail user creation
		// User can resend verification email later
		fmt.Printf("Warning: Failed to send verification email: %v\n", err)
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User created successfully. Please check your email to verify your account.",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.UserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: owner OR admin
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.UserResponse{
			Success: false,
			Message: "Forbidden: You can only update your own profile or be an admin",
		}, nil
	}

	// Prepare update request
	isAdminValue := false
	if input.IsAdmin != nil {
		isAdminValue = *input.IsAdmin
	}
	isBlockedValue := false
	if input.IsBlocked != nil {
		isBlockedValue = *input.IsBlocked
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.UpdateUser(ctx, &userPb.UpdateUserRequest{
		Id:          targetUserID,
		Name:        input.Name,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdminValue,
		IsBlocked:   isBlockedValue,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Update user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User updated successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.DeleteUserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: admin only OR own account
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Forbidden: Only admins can delete users or you can delete your own account",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.DeleteUser(ctx, &userPb.DeleteUserRequest{
		Id: targetUserID,
	})
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: fmt.Sprintf("Delete user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.DeleteUserResponse{
		Success: true,
		Message: "User deleted successfully",
	}, nil
}

// BulkDeleteUsers is the resolver for the bulkDeleteUsers field.
func (r *mutationResolver) BulkDeleteUsers(ctx context.Context, ids []string) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk delete users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkDeleteUsers(ctx, &userPb.BulkDeleteUsersRequest{
		UserIds: userIDs,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk delete users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.DeletedCount,
		}, nil
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       "Users deleted successfully",
		AffectedCount: resp.DeletedCount,
	}, nil
}

// BulkBlockUsers is the resolver for the bulkBlockUsers field.
func (r *mutationResolver) BulkBlockUsers(ctx context.Context, ids []string, isBlocked bool) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk block/unblock users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkBlockUsers(ctx, &userPb.BulkBlockUsersRequest{
		UserIds:   userIDs,
		IsBlocked: isBlocked,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk block users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.AffectedCount,
		}, nil
	}

	action := "blocked"
	if !isBlocked {
		action = "unblocked"
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       fmt.Sprintf("Users %s successfully", action),
		AffectedCount: resp.AffectedCount,
	}, nil
}

// CreateTenant is the resolver for the createTenant field.
func (r *mutationResolver) CreateTenant(ctx context.Context, input model.CreateTenantInput) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.CreateTenant(ctx, &tenantPb.CreateTenantRequest{
		Name:      input.Name,
		Slug:      util.StringValue(input.Slug),
		Domain:    util.StringValue(input.Domain),
		CreatedBy: userClaims.Id,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant created successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input model.UpdateTenantInput) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.UpdateTenant(ctx, &tenantPb.UpdateTenantRequest{
		Id:     tenantID,
		Name:   input.Name,
		Domain: util.StringValue(input.Domain),
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to update tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant updated successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// DeleteTenant is the resolver for the deleteTenant field.
func (r *mutationResolver) DeleteTenant(ctx context.Context, id string) (*model.DeleteTenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.DeleteTenant(ctx, &tenantPb.DeleteTenantRequest{
		Id: tenantID,
	})
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to delete tenant: %v", err),
		}, nil
	}

	return &model.DeleteTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// AddUserToTenant is the resolver for the addUserToTenant field.
func (r *mutationResolver) AddUserToTenant(ctx context.Context, input model.AddUserToTenantInput) (*model.TenantUserResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Get user email first
	userResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: userID,
	})
	if err != nil || !userResp.Success {
		return &model.TenantUserResponse{
			Success: false,
			Message: "User not found",
		}, nil
	}

	isDefault := false
	if input.IsDefault != nil {
		isDefault = *input.IsDefault
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.AddUserToTenant(ctx, &tenantPb.AddUserToTenantRequest{
		UserId:    userID,
		TenantId:  tenantID,
		Role:      input.Role,
		IsDefault: isDefault,
		Email:     userResp.Data.Email,
	})
	if err != nil {
		return &model.TenantUserResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to add user to tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenantUser := resp.Data
	return &model.TenantUserResponse{
		Success: true,
		Message: "User added to tenant successfully",
		Data: &model.TenantUser{
			ID:        strconv.FormatInt(tenantUser.Id, 10),
			UserID:    strconv.FormatInt(tenantUser.UserId, 10),
			TenantID:  strconv.FormatInt(tenantUser.TenantId, 10),
			Role:      tenantUser.Role,
			IsDefault: tenantUser.IsDefault,
			Email:     tenantUser.Email,
			CreatedAt: int32(tenantUser.CreatedAt),
			UpdatedAt: int32(tenantUser.UpdatedAt),
		},
	}, nil
}

// RemoveUserFromTenant is the resolver for the removeUserFromTenant field.
func (r *mutationResolver) RemoveUserFromTenant(ctx context.Context, userID string, tenantID string) (*model.DeleteTenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	parsedUserID, err := strconv.ParseInt(userID, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	parsedTenantID, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.RemoveUserFromTenant(ctx, &tenantPb.RemoveUserFromTenantRequest{
		UserId:   parsedUserID,
		TenantId: parsedTenantID,
	})
	if err != nil {
		return &model.DeleteTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to remove user from tenant: %v", err),
		}, nil
	}

	return &model.DeleteTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, input model.UpdateUserRoleInput) (*model.UpdateUserRoleResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.UpdateUserRole(ctx, &tenantPb.UpdateUserRoleRequest{
		UserId:   userID,
		TenantId: tenantID,
		Role:     input.Role,
	})
	if err != nil {
		return &model.UpdateUserRoleResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to update user role: %v", err),
		}, nil
	}

	return &model.UpdateUserRoleResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// SetDefaultTenant is the resolver for the setDefaultTenant field.
func (r *mutationResolver) SetDefaultTenant(ctx context.Context, input model.SetDefaultTenantInput) (*model.SetDefaultTenantResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userID, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.SetDefaultTenant(ctx, &tenantPb.SetDefaultTenantRequest{
		UserId:   userID,
		TenantId: tenantID,
	})
	if err != nil {
		return &model.SetDefaultTenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to set default tenant: %v", err),
		}, nil
	}

	return &model.SetDefaultTenantResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// SetTenantSetting is the resolver for the setTenantSetting field.
func (r *mutationResolver) SetTenantSetting(ctx context.Context, input model.SetSettingInput) (*model.TenantSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantID, err := strconv.ParseInt(input.TenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.SetSetting(ctx, &tenantPb.SetSettingRequest{
		TenantId: tenantID,
		Key:      input.Key,
		Value:    input.Value,
	})
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to set tenant setting: %v", err),
		}, nil
	}

	if !resp.Success || resp.Data == nil {
		return &model.TenantSettingResponse{
			Success: resp.Success,
			Message: resp.Message,
		}, nil
	}

	setting := resp.Data
	return &model.TenantSettingResponse{
		Success: true,
		Message: "Tenant setting saved successfully",
		Data: &model.TenantSetting{
			ID:        strconv.FormatInt(setting.Id, 10),
			TenantID:  strconv.FormatInt(setting.TenantId, 10),
			Key:       setting.Key,
			Value:     setting.Value,
			CreatedAt: int32(setting.CreatedAt),
			UpdatedAt: int32(setting.UpdatedAt),
		},
	}, nil
}

// DeleteTenantSetting is the resolver for the deleteTenantSetting field.
func (r *mutationResolver) DeleteTenantSetting(ctx context.Context, tenantID string, key string) (*model.DeleteSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.DeleteSetting(ctx, &tenantPb.DeleteSettingRequest{
		TenantId: tenantIDInt,
		Key:      key,
	})
	if err != nil {
		return &model.DeleteSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to delete tenant setting: %v", err),
		}, nil
	}

	return &model.DeleteSettingResponse{
		Success: resp.Success,
		Message: resp.Message,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.UserResponse, error) {
	userID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: userID,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetAllUsers(ctx, &userPb.GetAllUsersRequest{
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Get users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users retrieved successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.SearchUsers(ctx, &userPb.SearchUsersRequest{
		Query:   query,
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Search users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users search completed successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user details from user-service
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get current user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "Current user retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// VerifyResetToken is the resolver for the verifyResetToken field.
func (r *queryResolver) VerifyResetToken(ctx context.Context, token string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyResetToken(ctx, &authPb.VerifyResetTokenRequest{
		Token: token,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Verify reset token failed: %v", err),
		}, nil
	}

	if !resp.Valid {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Reset token is valid",
	}, nil
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context, id string) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	tenantID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantByID(ctx, &tenantPb.GetTenantByIDRequest{
		Id: tenantID,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant retrieved successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// TenantBySlug is the resolver for the tenantBySlug field.
func (r *queryResolver) TenantBySlug(ctx context.Context, slug string) (*model.TenantResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantBySlug(ctx, &tenantPb.GetTenantBySlugRequest{
		Slug: slug,
	})
	if err != nil {
		return &model.TenantResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	tenant := resp.Data
	return &model.TenantResponse{
		Success: true,
		Message: "Tenant retrieved successfully",
		Data: &model.Tenant{
			ID:                  strconv.FormatInt(tenant.Id, 10),
			UUID:                tenant.Uuid,
			Name:                tenant.Name,
			Slug:                tenant.Slug,
			Domain:              util.StringPtr(tenant.Domain),
			IsNameAutoGenerated: tenant.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(tenant.CreatedBy, 10),
			CreatedAt:           int32(tenant.CreatedAt),
			UpdatedAt:           int32(tenant.UpdatedAt),
		},
	}, nil
}

// Tenants is the resolver for the tenants field.
func (r *queryResolver) Tenants(ctx context.Context, page *int32, perPage *int32) (*model.TenantListResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantListResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	// Set default pagination
	pageValue := int32(1)
	perPageValue := int32(10)
	if page != nil {
		pageValue = *page
	}
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetAllTenants(ctx, &tenantPb.GetAllTenantsRequest{
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.TenantListResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenants: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert tenants
	tenants := make([]*model.Tenant, len(resp.Data.Tenants))
	for i, t := range resp.Data.Tenants {
		tenants[i] = &model.Tenant{
			ID:                  strconv.FormatInt(t.Id, 10),
			UUID:                t.Uuid,
			Name:                t.Name,
			Slug:                t.Slug,
			Domain:              util.StringPtr(t.Domain),
			IsNameAutoGenerated: t.IsNameAutoGenerated,
			CreatedBy:           strconv.FormatInt(t.CreatedBy, 10),
			CreatedAt:           int32(t.CreatedAt),
			UpdatedAt:           int32(t.UpdatedAt),
		}
	}

	return &model.TenantListResponse{
		Success: true,
		Message: "Tenants retrieved successfully",
		Data: &model.TenantList{
			Tenants: tenants,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// TenantUsers is the resolver for the tenantUsers field.
func (r *queryResolver) TenantUsers(ctx context.Context, tenantID string) (*model.TenantUsersResponse, error) {
	// Check if user is admin
	userClaims, err := middleware.GetUserFromContext(ctx)
	if err != nil || userClaims == nil || !userClaims.IsAdmin {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Unauthorized: Admin access required",
		}, nil
	}

	parsedTenantID, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	// Call tenant-service via gRPC
	resp, err := r.TenantClient.GetTenantUsers(ctx, &tenantPb.GetTenantUsersRequest{
		TenantId: parsedTenantID,
	})
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant users: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUsersResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert tenant users
	tenantUsers := make([]*model.TenantUser, len(resp.Data))
	for i, tu := range resp.Data {
		tenantUsers[i] = &model.TenantUser{
			ID:        strconv.FormatInt(tu.Id, 10),
			UserID:    strconv.FormatInt(tu.UserId, 10),
			TenantID:  strconv.FormatInt(tu.TenantId, 10),
			Role:      tu.Role,
			IsDefault: tu.IsDefault,
			Email:     tu.Email,
			CreatedAt: int32(tu.CreatedAt),
			UpdatedAt: int32(tu.UpdatedAt),
		}
	}

	return &model.TenantUsersResponse{
		Success: true,
		Message: "Tenant users retrieved successfully",
		Data:    tenantUsers,
	}, nil
}

// UserTenants is the resolver for the userTenants field.
func (r *queryResolver) UserTenants(ctx context.Context, userID string) (*model.TenantUsersResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	userIDInt, err := strconv.ParseInt(userID, 10, 64)
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	resp, err := r.TenantClient.GetUserTenants(ctx, &tenantPb.GetUserTenantsRequest{
		UserId: userIDInt,
	})
	if err != nil {
		return &model.TenantUsersResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get user tenants: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantUsersResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	var tenantUsers []*model.TenantUser
	for _, tu := range resp.Data {
		tenantUsers = append(tenantUsers, &model.TenantUser{
			ID:        strconv.FormatInt(tu.Id, 10),
			UserID:    strconv.FormatInt(tu.UserId, 10),
			TenantID:  strconv.FormatInt(tu.TenantId, 10),
			Role:      tu.Role,
			IsDefault: tu.IsDefault,
			Email:     tu.Email,
			CreatedAt: int32(tu.CreatedAt),
			UpdatedAt: int32(tu.UpdatedAt),
		})
	}

	return &model.TenantUsersResponse{
		Success: true,
		Message: "User tenants retrieved successfully",
		Data:    tenantUsers,
	}, nil
}

// TenantSetting is the resolver for the tenantSetting field.
func (r *queryResolver) TenantSetting(ctx context.Context, tenantID string, key string) (*model.TenantSettingResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.GetSetting(ctx, &tenantPb.GetSettingRequest{
		TenantId: tenantIDInt,
		Key:      key,
	})
	if err != nil {
		return &model.TenantSettingResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant setting: %v", err),
		}, nil
	}

	if !resp.Success || resp.Data == nil {
		return &model.TenantSettingResponse{
			Success: resp.Success,
			Message: resp.Message,
		}, nil
	}

	setting := resp.Data
	return &model.TenantSettingResponse{
		Success: true,
		Message: "Tenant setting retrieved successfully",
		Data: &model.TenantSetting{
			ID:        strconv.FormatInt(setting.Id, 10),
			TenantID:  strconv.FormatInt(setting.TenantId, 10),
			Key:       setting.Key,
			Value:     setting.Value,
			CreatedAt: int32(setting.CreatedAt),
			UpdatedAt: int32(setting.UpdatedAt),
		},
	}, nil
}

// TenantSettings is the resolver for the tenantSettings field.
func (r *queryResolver) TenantSettings(ctx context.Context, tenantID string) (*model.TenantSettingsResponse, error) {
	// Check admin authorization
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: "Unauthorized: Please login first",
		}, nil
	}

	tenantIDInt, err := strconv.ParseInt(tenantID, 10, 64)
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: "Invalid tenant ID",
		}, nil
	}

	resp, err := r.TenantClient.GetAllSettings(ctx, &tenantPb.GetAllSettingsRequest{
		TenantId: tenantIDInt,
	})
	if err != nil {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to get tenant settings: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.TenantSettingsResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	var settings []*model.TenantSetting
	for _, s := range resp.Data {
		settings = append(settings, &model.TenantSetting{
			ID:        strconv.FormatInt(s.Id, 10),
			TenantID:  strconv.FormatInt(s.TenantId, 10),
			Key:       s.Key,
			Value:     s.Value,
			CreatedAt: int32(s.CreatedAt),
			UpdatedAt: int32(s.UpdatedAt),
		})
	}

	return &model.TenantSettingsResponse{
		Success: true,
		Message: "Tenant settings retrieved successfully",
		Data:    settings,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type (
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)
