package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"strconv"

	"github.com/damarteplok/damar-admin-cms/services/api-gateway/graph/model"
	"github.com/damarteplok/damar-admin-cms/services/api-gateway/internal/middleware"
	authPb "github.com/damarteplok/damar-admin-cms/shared/proto/auth"
	userPb "github.com/damarteplok/damar-admin-cms/shared/proto/user"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Login(ctx, &authPb.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	})
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: fmt.Sprintf("Login failed: %v", err),
		}, nil
	}

	// Convert proto response to GraphQL model
	if !resp.Success {
		return &model.LoginResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	userData := resp.Data
	emailVerifiedAt := int32(userData.User.EmailVerifiedAt)
	lastLoginAt := int32(userData.User.LastLoginAt)
	createdAt := int32(userData.User.CreatedAt)
	updatedAt := int32(userData.User.UpdatedAt)

	return &model.LoginResponse{
		Success: true,
		Message: "Login successful",
		Data: &model.LoginData{
			AccessToken:  userData.AccessToken,
			RefreshToken: userData.RefreshToken,
			User: &model.User{
				ID:              fmt.Sprintf("%d", userData.User.Id),
				Name:            userData.User.Name,
				Email:           userData.User.Email,
				PublicName:      &userData.User.PublicName,
				IsAdmin:         userData.User.IsAdmin,
				IsBlocked:       userData.User.IsBlocked,
				PhoneNumber:     &userData.User.PhoneNumber,
				Position:        &userData.User.Position,
				EmailVerified:   userData.User.EmailVerified,
				EmailVerifiedAt: &emailVerifiedAt,
				LastLoginAt:     &lastLoginAt,
				CreatedAt:       &createdAt,
				UpdatedAt:       &updatedAt,
			},
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, refreshToken string) (*model.LogoutResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.Logout(ctx, &authPb.LogoutRequest{
		RefreshToken: refreshToken,
	})
	if err != nil {
		return &model.LogoutResponse{
			Success: false,
			Message: fmt.Sprintf("Logout failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.LogoutResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.LogoutResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.RefreshTokenResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.RefreshToken(ctx, &authPb.RefreshTokenRequest{
		RefreshToken: input.RefreshToken,
	})
	if err != nil {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: fmt.Sprintf("Refresh token failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.RefreshTokenResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.RefreshTokenResponse{
		Success: true,
		Message: "Token refreshed successfully",
		Data: &model.RefreshTokenData{
			AccessToken: resp.Data.AccessToken,
		},
	}, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (*model.ChangePasswordResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.ChangePassword(ctx, &authPb.ChangePasswordRequest{
		UserId:      currentUser.Id,
		OldPassword: input.OldPassword,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Change password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ChangePasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ChangePasswordResponse{
		Success: true,
		Message: "Password changed successfully",
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ForgotPassword(ctx, &authPb.ForgotPasswordRequest{
		Email: email,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Forgot password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Password reset email sent successfully",
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.ResetPassword(ctx, &authPb.ResetPasswordRequest{
		Token:       input.Token,
		NewPassword: input.NewPassword,
	})
	if err != nil {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Reset password failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.ResetPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ResetPasswordResponse{
		Success: true,
		Message: "Password reset successfully",
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (*model.VerifyEmailResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyEmail(ctx, &authPb.VerifyEmailRequest{
		Token: token,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Email verification failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Email verified successfully",
	}, nil
}

// ResendVerificationEmail is the resolver for the resendVerificationEmail field.
func (r *mutationResolver) ResendVerificationEmail(ctx context.Context) (*model.VerifyEmailResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user email from user-service
	userResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !userResp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: "Failed to get user information",
		}, nil
	}

	// Call auth-service via gRPC
	resp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: currentUser.Id,
		Email:  userResp.Data.Email,
	})
	if err != nil {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: fmt.Sprintf("Resend verification email failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.VerifyEmailResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.VerifyEmailResponse{
		Success: true,
		Message: "Verification email sent successfully",
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserResponse, error) {
	// Public registration - no auth check needed
	isAdmin := false
	if input.IsAdmin != nil {
		isAdmin = *input.IsAdmin
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.CreateUser(ctx, &userPb.CreateUserRequest{
		Name:        input.Name,
		Email:       input.Email,
		Password:    input.Password,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdmin,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Create user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Generate verification token after user creation
	verifyResp, err := r.AuthClient.SendVerificationEmail(ctx, &authPb.SendVerificationEmailRequest{
		UserId: resp.Data.Id,
		Email:  resp.Data.Email,
	})
	if err != nil || !verifyResp.Success {
		// Log error but don't fail user creation
		// User can resend verification email later
		fmt.Printf("Warning: Failed to send verification email: %v\n", err)
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User created successfully. Please check your email to verify your account.",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(input.ID, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.UserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: owner OR admin
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.UserResponse{
			Success: false,
			Message: "Forbidden: You can only update your own profile or be an admin",
		}, nil
	}

	// Prepare update request
	isAdminValue := false
	if input.IsAdmin != nil {
		isAdminValue = *input.IsAdmin
	}
	isBlockedValue := false
	if input.IsBlocked != nil {
		isBlockedValue = *input.IsBlocked
	}

	// Handle optional string pointers
	publicName := ""
	if input.PublicName != nil {
		publicName = *input.PublicName
	}
	phoneNumber := ""
	if input.PhoneNumber != nil {
		phoneNumber = *input.PhoneNumber
	}
	position := ""
	if input.Position != nil {
		position = *input.Position
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.UpdateUser(ctx, &userPb.UpdateUserRequest{
		Id:          targetUserID,
		Name:        input.Name,
		PublicName:  publicName,
		PhoneNumber: phoneNumber,
		Position:    position,
		IsAdmin:     isAdminValue,
		IsBlocked:   isBlockedValue,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Update user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User updated successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.DeleteUserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	targetUserID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Unauthorized: User not found",
		}, nil
	}

	// Authorization check: admin only OR own account
	isOwner := currentUser.Id == targetUserID
	isAdmin := currentUserResp.Data.IsAdmin

	if !isOwner && !isAdmin {
		return &model.DeleteUserResponse{
			Success: false,
			Message: "Forbidden: Only admins can delete users or you can delete your own account",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.DeleteUser(ctx, &userPb.DeleteUserRequest{
		Id: targetUserID,
	})
	if err != nil {
		return &model.DeleteUserResponse{
			Success: false,
			Message: fmt.Sprintf("Delete user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.DeleteUserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.DeleteUserResponse{
		Success: true,
		Message: "User deleted successfully",
	}, nil
}

// BulkDeleteUsers is the resolver for the bulkDeleteUsers field.
func (r *mutationResolver) BulkDeleteUsers(ctx context.Context, ids []string) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk delete users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkDeleteUsers(ctx, &userPb.BulkDeleteUsersRequest{
		UserIds: userIDs,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk delete users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.DeletedCount,
		}, nil
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       "Users deleted successfully",
		AffectedCount: resp.DeletedCount,
	}, nil
}

// BulkBlockUsers is the resolver for the bulkBlockUsers field.
func (r *mutationResolver) BulkBlockUsers(ctx context.Context, ids []string, isBlocked bool) (*model.BulkOperationResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       err.Error(),
			AffectedCount: 0,
		}, nil
	}

	// Get current user full info to check if admin
	currentUserResp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil || !currentUserResp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Unauthorized: User not found",
			AffectedCount: 0,
		}, nil
	}

	// Authorization check: admin only
	if !currentUserResp.Data.IsAdmin {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       "Forbidden: Only admins can bulk block/unblock users",
			AffectedCount: 0,
		}, nil
	}

	// Convert string IDs to int64
	userIDs := make([]int64, len(ids))
	for i, id := range ids {
		userID, err := strconv.ParseInt(id, 10, 64)
		if err != nil {
			return &model.BulkOperationResponse{
				Success:       false,
				Message:       fmt.Sprintf("Invalid user ID: %s", id),
				AffectedCount: 0,
			}, nil
		}
		userIDs[i] = userID
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.BulkBlockUsers(ctx, &userPb.BulkBlockUsersRequest{
		UserIds:   userIDs,
		IsBlocked: isBlocked,
	})
	if err != nil {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       fmt.Sprintf("Bulk block users failed: %v", err),
			AffectedCount: 0,
		}, nil
	}

	if !resp.Success {
		return &model.BulkOperationResponse{
			Success:       false,
			Message:       resp.Message,
			AffectedCount: resp.AffectedCount,
		}, nil
	}

	action := "blocked"
	if !isBlocked {
		action = "unblocked"
	}

	return &model.BulkOperationResponse{
		Success:       true,
		Message:       fmt.Sprintf("Users %s successfully", action),
		AffectedCount: resp.AffectedCount,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.UserResponse, error) {
	userID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: "Invalid user ID",
		}, nil
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: userID,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "User retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.GetAllUsers(ctx, &userPb.GetAllUsersRequest{
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Get users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users retrieved successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, page *int32, perPage *int32) (*model.UserListResponse, error) {
	// Default pagination
	pageValue := int32(1)
	if page != nil {
		pageValue = *page
	}
	perPageValue := int32(10)
	if perPage != nil {
		perPageValue = *perPage
	}

	// Call user-service via gRPC
	resp, err := r.UserClient.SearchUsers(ctx, &userPb.SearchUsersRequest{
		Query:   query,
		Page:    pageValue,
		PerPage: perPageValue,
	})
	if err != nil {
		return &model.UserListResponse{
			Success: false,
			Message: fmt.Sprintf("Search users failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserListResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	// Convert users
	users := make([]*model.User, len(resp.Data.Users))
	for i, u := range resp.Data.Users {
		users[i] = &model.User{
			ID:          fmt.Sprintf("%d", u.Id),
			Name:        u.Name,
			Email:       u.Email,
			PublicName:  &u.PublicName,
			IsAdmin:     u.IsAdmin,
			IsBlocked:   u.IsBlocked,
			PhoneNumber: &u.PhoneNumber,
			Position:    &u.Position,
		}
	}

	return &model.UserListResponse{
		Success: true,
		Message: "Users search completed successfully",
		Data: &model.UserList{
			Users:   users,
			Total:   resp.Data.Total,
			Page:    resp.Data.Page,
			PerPage: resp.Data.PerPage,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.UserResponse, error) {
	// Get authenticated user from context
	currentUser, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	// Get user details from user-service
	resp, err := r.UserClient.GetUserByID(ctx, &userPb.GetUserByIDRequest{
		Id: currentUser.Id,
	})
	if err != nil {
		return &model.UserResponse{
			Success: false,
			Message: fmt.Sprintf("Get current user failed: %v", err),
		}, nil
	}

	if !resp.Success {
		return &model.UserResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	emailVerifiedAt := int32(resp.Data.EmailVerifiedAt)
	lastLoginAt := int32(resp.Data.LastLoginAt)
	createdAt := int32(resp.Data.CreatedAt)
	updatedAt := int32(resp.Data.UpdatedAt)

	return &model.UserResponse{
		Success: true,
		Message: "Current user retrieved successfully",
		Data: &model.User{
			ID:              fmt.Sprintf("%d", resp.Data.Id),
			Name:            resp.Data.Name,
			Email:           resp.Data.Email,
			PublicName:      &resp.Data.PublicName,
			IsAdmin:         resp.Data.IsAdmin,
			IsBlocked:       resp.Data.IsBlocked,
			PhoneNumber:     &resp.Data.PhoneNumber,
			Position:        &resp.Data.Position,
			EmailVerified:   resp.Data.EmailVerified,
			EmailVerifiedAt: &emailVerifiedAt,
			LastLoginAt:     &lastLoginAt,
			CreatedAt:       &createdAt,
			UpdatedAt:       &updatedAt,
		},
	}, nil
}

// VerifyResetToken is the resolver for the verifyResetToken field.
func (r *queryResolver) VerifyResetToken(ctx context.Context, token string) (*model.ForgotPasswordResponse, error) {
	// Call auth-service via gRPC
	resp, err := r.AuthClient.VerifyResetToken(ctx, &authPb.VerifyResetTokenRequest{
		Token: token,
	})
	if err != nil {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: fmt.Sprintf("Verify reset token failed: %v", err),
		}, nil
	}

	if !resp.Valid {
		return &model.ForgotPasswordResponse{
			Success: false,
			Message: resp.Message,
		}, nil
	}

	return &model.ForgotPasswordResponse{
		Success: true,
		Message: "Reset token is valid",
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type (
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)
