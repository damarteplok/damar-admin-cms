package repository

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/damarteplok/damar-admin-cms/services/tenant-service/internal/domain"
	"github.com/jackc/pgx/v5/pgxpool"
)

type TenantRepository struct {
	db *pgxpool.Pool
}

func NewTenantRepository(db *pgxpool.Pool) domain.TenantRepository {
	return &TenantRepository{db: db}
}

// Tenant operations

func (r *TenantRepository) GetByID(ctx context.Context, id int64) (*domain.Tenant, error) {
	query := `
		SELECT id, uuid, name, slug, domain, is_name_auto_generated, 
		       created_by, created_at, updated_at, deleted_at
		FROM tenants
		WHERE id = $1 AND deleted_at IS NULL
	`

	tenant := &domain.Tenant{}
	err := r.db.QueryRow(ctx, query, id).Scan(
		&tenant.ID,
		&tenant.UUID,
		&tenant.Name,
		&tenant.Slug,
		&tenant.Domain,
		&tenant.IsNameAutoGenerated,
		&tenant.CreatedBy,
		&tenant.CreatedAt,
		&tenant.UpdatedAt,
		&tenant.DeletedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant by ID: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) GetByUUID(ctx context.Context, uuid string) (*domain.Tenant, error) {
	query := `
		SELECT id, uuid, name, slug, domain, is_name_auto_generated, 
		       created_by, created_at, updated_at, deleted_at
		FROM tenants
		WHERE uuid = $1 AND deleted_at IS NULL
	`

	tenant := &domain.Tenant{}
	err := r.db.QueryRow(ctx, query, uuid).Scan(
		&tenant.ID,
		&tenant.UUID,
		&tenant.Name,
		&tenant.Slug,
		&tenant.Domain,
		&tenant.IsNameAutoGenerated,
		&tenant.CreatedBy,
		&tenant.CreatedAt,
		&tenant.UpdatedAt,
		&tenant.DeletedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant by UUID: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) GetBySlug(ctx context.Context, slug string) (*domain.Tenant, error) {
	query := `
		SELECT id, uuid, name, slug, domain, is_name_auto_generated, 
		       created_by, created_at, updated_at, deleted_at
		FROM tenants
		WHERE slug = $1 AND deleted_at IS NULL
	`

	tenant := &domain.Tenant{}
	err := r.db.QueryRow(ctx, query, slug).Scan(
		&tenant.ID,
		&tenant.UUID,
		&tenant.Name,
		&tenant.Slug,
		&tenant.Domain,
		&tenant.IsNameAutoGenerated,
		&tenant.CreatedBy,
		&tenant.CreatedAt,
		&tenant.UpdatedAt,
		&tenant.DeletedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant by slug: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) GetByDomain(ctx context.Context, domainName string) (*domain.Tenant, error) {
	query := `
		SELECT id, uuid, name, slug, domain, is_name_auto_generated, 
		       created_by, created_at, updated_at, deleted_at
		FROM tenants
		WHERE domain = $1 AND deleted_at IS NULL
	`

	tenant := &domain.Tenant{}
	err := r.db.QueryRow(ctx, query, domainName).Scan(
		&tenant.ID,
		&tenant.UUID,
		&tenant.Name,
		&tenant.Slug,
		&tenant.Domain,
		&tenant.IsNameAutoGenerated,
		&tenant.CreatedBy,
		&tenant.CreatedAt,
		&tenant.UpdatedAt,
		&tenant.DeletedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant by domain: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) Create(ctx context.Context, tenant *domain.Tenant) (*domain.Tenant, error) {
	query := `
		INSERT INTO tenants (uuid, name, slug, domain, is_name_auto_generated, created_by, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
		RETURNING id, created_at, updated_at
	`

	err := r.db.QueryRow(
		ctx,
		query,
		tenant.UUID,
		tenant.Name,
		tenant.Slug,
		tenant.Domain,
		tenant.IsNameAutoGenerated,
		tenant.CreatedBy,
	).Scan(&tenant.ID, &tenant.CreatedAt, &tenant.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to create tenant: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) Update(ctx context.Context, tenant *domain.Tenant) (*domain.Tenant, error) {
	query := `
		UPDATE tenants 
		SET name = $1, domain = $2, updated_at = NOW()
		WHERE id = $3 AND deleted_at IS NULL
		RETURNING updated_at
	`

	err := r.db.QueryRow(
		ctx,
		query,
		tenant.Name,
		tenant.Domain,
		tenant.ID,
	).Scan(&tenant.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to update tenant: %w", err)
	}

	return tenant, nil
}

func (r *TenantRepository) Delete(ctx context.Context, id int64) error {
	query := `
		UPDATE tenants 
		SET deleted_at = NOW()
		WHERE id = $1 AND deleted_at IS NULL
	`

	result, err := r.db.Exec(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete tenant: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("tenant not found")
	}

	return nil
}

func (r *TenantRepository) GetAll(ctx context.Context, page, perPage int, search, sortBy, sortOrder string) ([]*domain.Tenant, int64, error) {
	offset := (page - 1) * perPage

	// Build WHERE clause with search
	whereClause := "deleted_at IS NULL"
	var args []interface{}
	argIndex := 1

	if search != "" {
		searchPattern := "%" + search + "%"
		whereClause += fmt.Sprintf(" AND (name ILIKE $%d OR slug ILIKE $%d OR domain ILIKE $%d)", argIndex, argIndex, argIndex)
		args = append(args, searchPattern)
		argIndex++
	}

	// Get total count
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM tenants WHERE %s", whereClause)
	var total int64
	err := r.db.QueryRow(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count tenants: %w", err)
	}

	// Validate and build ORDER BY clause
	if sortBy == "" {
		sortBy = "created_at"
	}

	// Whitelist allowed sort fields (security: prevent SQL injection)
	allowedSortFields := map[string]bool{
		"id": true, "name": true, "slug": true,
		"domain": true, "created_at": true, "updated_at": true,
	}
	if !allowedSortFields[sortBy] {
		sortBy = "created_at"
	}

	// Validate sort order
	if sortOrder != "asc" && sortOrder != "desc" {
		sortOrder = "desc"
	}

	orderClause := fmt.Sprintf("%s %s", sortBy, strings.ToUpper(sortOrder))

	// Get paginated results
	query := fmt.Sprintf(`
		SELECT id, uuid, name, slug, domain, is_name_auto_generated, 
		       created_by, created_at, updated_at, deleted_at
		FROM tenants
		WHERE %s
		ORDER BY %s
		LIMIT $%d OFFSET $%d
	`, whereClause, orderClause, argIndex, argIndex+1)

	args = append(args, perPage, offset)

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get tenants: %w", err)
	}
	defer rows.Close()

	var tenants []*domain.Tenant
	for rows.Next() {
		tenant := &domain.Tenant{}
		err := rows.Scan(
			&tenant.ID,
			&tenant.UUID,
			&tenant.Name,
			&tenant.Slug,
			&tenant.Domain,
			&tenant.IsNameAutoGenerated,
			&tenant.CreatedBy,
			&tenant.CreatedAt,
			&tenant.UpdatedAt,
			&tenant.DeletedAt,
		)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to scan tenant: %w", err)
		}
		tenants = append(tenants, tenant)
	}

	return tenants, total, nil
}

func (r *TenantRepository) GetUserTenants(ctx context.Context, userID int64) ([]*domain.TenantUser, error) {
	query := `
		SELECT id, user_id, tenant_id, role, is_default, email, created_at, updated_at
		FROM tenant_user
		WHERE user_id = $1
		ORDER BY is_default DESC, created_at ASC
	`

	rows, err := r.db.Query(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user tenants: %w", err)
	}
	defer rows.Close()

	var tenantUsers []*domain.TenantUser
	for rows.Next() {
		tu := &domain.TenantUser{}
		err := rows.Scan(
			&tu.ID,
			&tu.UserID,
			&tu.TenantID,
			&tu.Role,
			&tu.IsDefault,
			&tu.Email,
			&tu.CreatedAt,
			&tu.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan tenant user: %w", err)
		}
		tenantUsers = append(tenantUsers, tu)
	}

	return tenantUsers, nil
}

// TenantUser operations

func (r *TenantRepository) AddUserToTenant(ctx context.Context, tenantUser *domain.TenantUser) (*domain.TenantUser, error) {
	query := `
		INSERT INTO tenant_user (user_id, tenant_id, role, is_default, email, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
		RETURNING id, created_at, updated_at
	`

	err := r.db.QueryRow(
		ctx,
		query,
		tenantUser.UserID,
		tenantUser.TenantID,
		tenantUser.Role,
		tenantUser.IsDefault,
		tenantUser.Email,
	).Scan(&tenantUser.ID, &tenantUser.CreatedAt, &tenantUser.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to add user to tenant: %w", err)
	}

	return tenantUser, nil
}

func (r *TenantRepository) RemoveUserFromTenant(ctx context.Context, userID, tenantID int64) error {
	query := `DELETE FROM tenant_user WHERE user_id = $1 AND tenant_id = $2`

	result, err := r.db.Exec(ctx, query, userID, tenantID)
	if err != nil {
		return fmt.Errorf("failed to remove user from tenant: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("user-tenant relationship not found")
	}

	return nil
}

func (r *TenantRepository) GetTenantUsers(ctx context.Context, tenantID int64) ([]*domain.TenantUser, error) {
	query := `
		SELECT id, user_id, tenant_id, role, is_default, email, created_at, updated_at
		FROM tenant_user
		WHERE tenant_id = $1
		ORDER BY created_at ASC
	`

	rows, err := r.db.Query(ctx, query, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant users: %w", err)
	}
	defer rows.Close()

	var users []*domain.TenantUser
	for rows.Next() {
		tu := &domain.TenantUser{}
		err := rows.Scan(
			&tu.ID,
			&tu.UserID,
			&tu.TenantID,
			&tu.Role,
			&tu.IsDefault,
			&tu.Email,
			&tu.CreatedAt,
			&tu.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan tenant user: %w", err)
		}
		users = append(users, tu)
	}

	return users, nil
}

func (r *TenantRepository) GetUserRole(ctx context.Context, userID, tenantID int64) (string, error) {
	query := `
		SELECT role
		FROM tenant_user
		WHERE user_id = $1 AND tenant_id = $2
	`

	var role string
	err := r.db.QueryRow(ctx, query, userID, tenantID).Scan(&role)
	if err != nil {
		return "", fmt.Errorf("failed to get user role: %w", err)
	}

	return role, nil
}

func (r *TenantRepository) GetUserTenantRole(ctx context.Context, userID, tenantID int64) (*domain.TenantUser, error) {
	query := `
		SELECT id, user_id, tenant_id, role, is_default, email, created_at, updated_at
		FROM tenant_user
		WHERE user_id = $1 AND tenant_id = $2
	`

	tu := &domain.TenantUser{}
	err := r.db.QueryRow(ctx, query, userID, tenantID).Scan(
		&tu.ID,
		&tu.UserID,
		&tu.TenantID,
		&tu.Role,
		&tu.IsDefault,
		&tu.Email,
		&tu.CreatedAt,
		&tu.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get user tenant role: %w", err)
	}

	return tu, nil
}

func (r *TenantRepository) UpdateUserRole(ctx context.Context, userID, tenantID int64, role string) error {
	query := `
		UPDATE tenant_user 
		SET role = $1, updated_at = NOW()
		WHERE user_id = $2 AND tenant_id = $3
	`

	result, err := r.db.Exec(ctx, query, role, userID, tenantID)
	if err != nil {
		return fmt.Errorf("failed to update user role: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("user-tenant relationship not found")
	}

	return nil
}

func (r *TenantRepository) SetDefaultTenant(ctx context.Context, userID, tenantID int64) error {
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Unset all defaults for this user
	query1 := `UPDATE tenant_user SET is_default = false WHERE user_id = $1`
	_, err = tx.Exec(ctx, query1, userID)
	if err != nil {
		return fmt.Errorf("failed to unset defaults: %w", err)
	}

	// Set new default
	query2 := `UPDATE tenant_user SET is_default = true WHERE user_id = $1 AND tenant_id = $2`
	result, err := tx.Exec(ctx, query2, userID, tenantID)
	if err != nil {
		return fmt.Errorf("failed to set default: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("user-tenant relationship not found")
	}

	return tx.Commit(ctx)
}

// TenantSetting operations

func (r *TenantRepository) GetSetting(ctx context.Context, tenantID int64, key string) (*domain.TenantSetting, error) {
	query := `
		SELECT id, tenant_id, key, value, created_at, updated_at
		FROM tenant_settings
		WHERE tenant_id = $1 AND key = $2
	`

	setting := &domain.TenantSetting{}
	err := r.db.QueryRow(ctx, query, tenantID, key).Scan(
		&setting.ID,
		&setting.TenantID,
		&setting.Key,
		&setting.Value,
		&setting.CreatedAt,
		&setting.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get setting: %w", err)
	}

	return setting, nil
}

func (r *TenantRepository) GetAllSettings(ctx context.Context, tenantID int64) ([]*domain.TenantSetting, error) {
	query := `
		SELECT id, tenant_id, key, value, created_at, updated_at
		FROM tenant_settings
		WHERE tenant_id = $1
		ORDER BY key ASC
	`

	rows, err := r.db.Query(ctx, query, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to get settings: %w", err)
	}
	defer rows.Close()

	var settings []*domain.TenantSetting
	for rows.Next() {
		setting := &domain.TenantSetting{}
		err := rows.Scan(
			&setting.ID,
			&setting.TenantID,
			&setting.Key,
			&setting.Value,
			&setting.CreatedAt,
			&setting.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan setting: %w", err)
		}
		settings = append(settings, setting)
	}

	return settings, nil
}

func (r *TenantRepository) SetSetting(ctx context.Context, setting *domain.TenantSetting) (*domain.TenantSetting, error) {
	// Ensure value is valid JSON
	if !json.Valid(setting.Value) {
		return nil, fmt.Errorf("invalid JSON value")
	}

	query := `
		INSERT INTO tenant_settings (tenant_id, key, value, created_at, updated_at)
		VALUES ($1, $2, $3, NOW(), NOW())
		ON CONFLICT (tenant_id, key) 
		DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()
		RETURNING id, created_at, updated_at
	`

	err := r.db.QueryRow(
		ctx,
		query,
		setting.TenantID,
		setting.Key,
		setting.Value,
	).Scan(&setting.ID, &setting.CreatedAt, &setting.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to set setting: %w", err)
	}

	return setting, nil
}

func (r *TenantRepository) DeleteSetting(ctx context.Context, tenantID int64, key string) error {
	query := `DELETE FROM tenant_settings WHERE tenant_id = $1 AND key = $2`

	result, err := r.db.Exec(ctx, query, tenantID, key)
	if err != nil {
		return fmt.Errorf("failed to delete setting: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("setting not found")
	}

	return nil
}
