package service

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/damarteplok/damar-admin-cms/services/tenant-service/internal/domain"
	"github.com/google/uuid"
)

type TenantService struct {
	repo domain.TenantRepository
}

func NewTenantService(repo domain.TenantRepository) domain.TenantService {
	return &TenantService{repo: repo}
}

// Tenant operations

func (s *TenantService) GetTenantByID(ctx context.Context, id int64) (*domain.Tenant, error) {
	return s.repo.GetByID(ctx, id)
}

func (s *TenantService) GetTenantByUUID(ctx context.Context, uuidStr string) (*domain.Tenant, error) {
	return s.repo.GetByUUID(ctx, uuidStr)
}

func (s *TenantService) GetTenantBySlug(ctx context.Context, slug string) (*domain.Tenant, error) {
	return s.repo.GetBySlug(ctx, slug)
}

func (s *TenantService) GetTenantByDomain(ctx context.Context, domainStr string) (*domain.Tenant, error) {
	return s.repo.GetByDomain(ctx, domainStr)
}

func (s *TenantService) CreateTenant(ctx context.Context, tenant *domain.Tenant) (*domain.Tenant, error) {
	// Business validation: Generate UUID if not provided
	if tenant.UUID == "" {
		tenant.UUID = uuid.New().String()
	}

	// Business validation: Generate slug from name if not provided
	if tenant.Slug == "" {
		tenant.Slug = generateSlug(tenant.Name)
		tenant.IsNameAutoGenerated = true
	}

	// Business validation: Check if slug already exists
	existing, _ := s.repo.GetBySlug(ctx, tenant.Slug)
	if existing != nil {
		// If slug exists, append random suffix
		tenant.Slug = fmt.Sprintf("%s-%s", tenant.Slug, uuid.New().String()[:8])
	}

	// Business validation: Check if domain already exists (if provided)
	if tenant.Domain != nil && *tenant.Domain != "" {
		existing, _ := s.repo.GetByDomain(ctx, *tenant.Domain)
		if existing != nil {
			return nil, errors.New("domain already registered")
		}
	}

	return s.repo.Create(ctx, tenant)
}

func (s *TenantService) UpdateTenant(ctx context.Context, tenant *domain.Tenant) (*domain.Tenant, error) {
	// Business validation: Check if tenant exists
	existing, err := s.repo.GetByID(ctx, tenant.ID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}
	if existing == nil {
		return nil, errors.New("tenant not found")
	}

	// Business validation: Check if domain already exists (if changed and provided)
	if tenant.Domain != nil && *tenant.Domain != "" {
		if existing.Domain == nil || *existing.Domain != *tenant.Domain {
			domainExists, _ := s.repo.GetByDomain(ctx, *tenant.Domain)
			if domainExists != nil && domainExists.ID != tenant.ID {
				return nil, errors.New("domain already registered")
			}
		}
	}

	return s.repo.Update(ctx, tenant)
}

func (s *TenantService) DeleteTenant(ctx context.Context, id int64) error {
	// Business validation: Check if tenant exists
	existing, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return fmt.Errorf("tenant not found: %w", err)
	}
	if existing == nil {
		return errors.New("tenant not found")
	}

	return s.repo.Delete(ctx, id)
}

func (s *TenantService) GetAllTenants(ctx context.Context, page, perPage int, search, sortBy, sortOrder string) ([]*domain.Tenant, int64, error) {
	if page < 1 {
		page = 1
	}
	if perPage < 1 || perPage > 100 {
		perPage = 10
	}
	return s.repo.GetAll(ctx, page, perPage, search, sortBy, sortOrder)
}

// TenantUser operations

func (s *TenantService) AddUserToTenant(ctx context.Context, tenantUser *domain.TenantUser) (*domain.TenantUser, error) {
	// Business validation: Check if tenant exists
	_, err := s.repo.GetByID(ctx, tenantUser.TenantID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	// Business validation: Check if user already in tenant
	existing, _ := s.repo.GetUserTenantRole(ctx, tenantUser.UserID, tenantUser.TenantID)
	if existing != nil {
		return nil, errors.New("user already in tenant")
	}

	// Business validation: Validate role
	if !isValidRole(tenantUser.Role) {
		return nil, fmt.Errorf("invalid role: %s", tenantUser.Role)
	}

	return s.repo.AddUserToTenant(ctx, tenantUser)
}

func (s *TenantService) RemoveUserFromTenant(ctx context.Context, userID, tenantID int64) error {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return fmt.Errorf("tenant not found: %w", err)
	}

	// Business validation: Check if relationship exists
	_, err = s.repo.GetUserTenantRole(ctx, userID, tenantID)
	if err != nil {
		return fmt.Errorf("user not in tenant: %w", err)
	}

	return s.repo.RemoveUserFromTenant(ctx, userID, tenantID)
}

func (s *TenantService) GetTenantUsers(ctx context.Context, tenantID int64) ([]*domain.TenantUser, error) {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return s.repo.GetTenantUsers(ctx, tenantID)
}

func (s *TenantService) GetUserTenants(ctx context.Context, userID int64) ([]*domain.TenantUser, error) {
	return s.repo.GetUserTenants(ctx, userID)
}

func (s *TenantService) GetUserTenantRole(ctx context.Context, userID, tenantID int64) (*domain.TenantUser, error) {
	return s.repo.GetUserTenantRole(ctx, userID, tenantID)
}

func (s *TenantService) UpdateUserRole(ctx context.Context, userID, tenantID int64, role string) error {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return fmt.Errorf("tenant not found: %w", err)
	}

	// Business validation: Check if relationship exists
	_, err = s.repo.GetUserTenantRole(ctx, userID, tenantID)
	if err != nil {
		return fmt.Errorf("user not in tenant: %w", err)
	}

	// Business validation: Validate role
	if !isValidRole(role) {
		return fmt.Errorf("invalid role: %s", role)
	}

	return s.repo.UpdateUserRole(ctx, userID, tenantID, role)
}

func (s *TenantService) SetDefaultTenant(ctx context.Context, userID, tenantID int64) error {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return fmt.Errorf("tenant not found: %w", err)
	}

	// Business validation: Check if relationship exists
	_, err = s.repo.GetUserTenantRole(ctx, userID, tenantID)
	if err != nil {
		return fmt.Errorf("user not in tenant: %w", err)
	}

	return s.repo.SetDefaultTenant(ctx, userID, tenantID)
}

// TenantSetting operations

func (s *TenantService) GetSetting(ctx context.Context, tenantID int64, key string) (*domain.TenantSetting, error) {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return s.repo.GetSetting(ctx, tenantID, key)
}

func (s *TenantService) GetAllSettings(ctx context.Context, tenantID int64) ([]*domain.TenantSetting, error) {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return s.repo.GetAllSettings(ctx, tenantID)
}

func (s *TenantService) SetSetting(ctx context.Context, setting *domain.TenantSetting) (*domain.TenantSetting, error) {
	// Business validation: Check if tenant exists
	_, err := s.repo.GetByID(ctx, setting.TenantID)
	if err != nil {
		return nil, fmt.Errorf("tenant not found: %w", err)
	}

	return s.repo.SetSetting(ctx, setting)
}

func (s *TenantService) DeleteSetting(ctx context.Context, tenantID int64, key string) error {
	// Business validation: Check if tenant exists and is active
	_, err := s.repo.GetByID(ctx, tenantID)
	if err != nil {
		return fmt.Errorf("tenant not found: %w", err)
	}

	// Business validation: Check if setting exists
	_, err = s.repo.GetSetting(ctx, tenantID, key)
	if err != nil {
		return fmt.Errorf("setting not found: %w", err)
	}

	return s.repo.DeleteSetting(ctx, tenantID, key)
}

// Helper functions

func generateSlug(name string) string {
	slug := strings.ToLower(name)
	slug = strings.ReplaceAll(slug, " ", "-")
	// Remove special characters except hyphens
	var result strings.Builder
	for _, r := range slug {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '-' {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func isValidRole(role string) bool {
	validRoles := map[string]bool{
		"owner":  true,
		"admin":  true,
		"member": true,
		"guest":  true,
	}
	return validRoles[role]
}
